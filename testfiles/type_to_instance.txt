concrete Bool {}

// Comparable for equality.
interface Equals<x|> {
  x requires Equals<x>
  // eq takes (x) to (Bool)
}

// Comparable for less-than.
interface LessThan<x|> {
  x requires LessThan<x>
  // lt takes (x) to (Bool)
}

// Arbitrary key type.
interface AnyKey<k|> {
  inherits Equals<k>
  k requires AnyKey<k>
}

// A key for a specific instance type.
interface Key<k|x> {
  inherits AnyKey<k>
  k requires AnyKey<k>
}

// Identifier for an arbitrary Feature.
interface AnyFeatureId {
  inherits AnyKey<AnyFeatureId>
  inherits LessThan<AnyFeatureId>
}

// Identifier for a feature of a specific type.
concrete FeatureId<|x> {
  inherits AnyFeatureId
  inherits Key<AnyFeatureId,x>
}

/* Ideas for later ...

// Arbitrary value type.
interface AnyValue<|x> {
  any takes () to (x)
}

concrete Optional<|x> {
  present takes () to (Bool)
  get     takes () to (x)
}

concrete Value<k|x|> {
  inherits AnyValue<x>

  new<y>
    // How does variance work here? Can x be covariant?
    y requires x
    takes (Key<k,y>,y)

  get<y>
    takes (Key<k,y>)
    to    (Optional<y>)
}

interface Supplier<|x> {
  get takes () to (x)
}

// Some feature.
interface Feature {}

concrete FeatureManager {
  enable<x>
    x requires Feature
    takes (FeatureId<x>,
           Supplier<x>)
    to    (x)
}

// Something this somewhere...
Map<AnyFeatureId,Value<AnyFeatureId,Feature>> features;
FeatureId<F1> f1_key;
features.put(f1_key,new Value(f1_key,new F1()));
F1 f1 = features.get(f1_key).get(f1_key);

*/
