define MatchState {
  @value Int enum
  @value String name
  @category MatchState matchFailVal     <- MatchState{ 0, "matchFail" }
  @category MatchState matchContinueVal <- MatchState{ 1, "matchContinue" }
  @category MatchState matchEndVal      <- MatchState{ 2, "matchEnd" }
  @category MatchState matchCompleteVal <- MatchState{ 3, "matchComplete" }

  formatted () {
    return "MatchState$" + name + "()"
  }

  equals (x,y) {
    return x.getEnum() == y.getEnum()
  }

  lessThan (x,y) {
    return x.getEnum() < y.getEnum()
  }

  matchFail () {
    return matchFailVal
  }

  matchContinue () {
    return matchContinueVal
  }

  matchEnd () {
    return matchEndVal
  }

  matchComplete () {
    return matchCompleteVal
  }

  @value getEnum () -> (Int)
  getEnum () {
    return enum
  }
}

define MatchSingleChar {
  @value #c match
  @value MatchState state

  create (match) {
    return MatchSingleChar<#c>{ match, MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchSingleChar<#c>{ match, MatchState$matchContinue() }
  }

  tryNextMatch (data) (state2,data2,branch) {
    state2 <- MatchState$matchFail()
    data2 <- data
    branch <- empty
    if (MatchState$equals(state,MatchState$matchContinue()) &&
        !data.pastForwardEnd()) {
      #c current <- data.readCurrent()
      data2 <- data.forward()
      if (#c$equals(current,match)) {
        if (data2.pastForwardEnd()) {
          state2 <- MatchState$matchComplete()
        } else {
          state2 <- MatchState$matchEnd()
        }
      }
    }
    state <- state2
  }
}

define MatchCharRange {
  @value #c matchMin
  @value #c matchMax
  @value MatchState state

  create (matchMin,matchMax) {
    return MatchCharRange<#c>{ matchMin, matchMax, MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchCharRange<#c>{ matchMin, matchMax, MatchState$matchContinue() }
  }

  tryNextMatch (data) (state2,data2,branch) {
    state2 <- MatchState$matchFail()
    data2 <- data
    branch <- empty
    if (MatchState$equals(state,MatchState$matchContinue()) &&
        !data.pastForwardEnd()) {
      #c current <- data.readCurrent()
      data2 <- data.forward()
      if (!#c$lessThan(current,matchMin) && !#c$lessThan(matchMax,current)) {
        if (data2.pastForwardEnd()) {
          state2 <- MatchState$matchComplete()
        } else {
          state2 <- MatchState$matchEnd()
        }
      }
    }
    state <- state2
  }
}

define MatchAnyChar {
  @value MatchState state

  create () {
    return MatchAnyChar<#c>{ MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchAnyChar<#c>{ MatchState$matchContinue() }
  }

  tryNextMatch (data) (state2,data2,branch) {
    state2 <- MatchState$matchFail()
    data2 <- data
    branch <- empty
    if (MatchState$equals(state,MatchState$matchContinue()) &&
        !data.pastForwardEnd()) {
      #c current <- data.readCurrent()
      data2 <- data.forward()
      if (data2.pastForwardEnd()) {
        state2 <- MatchState$matchComplete()
      } else {
        state2 <- MatchState$matchEnd()
      }
    }
    state <- state2
  }
}

define RepeatMatcher {
  @value Matcher<#x> matcher
  @value Int min
  @value Int max // 0 means unlimited.
  @value Int repetitionCount

  createZeroPlus (matcher) {
    return createRange(0,0,matcher)
  }

  createOnePlus (matcher) {
    return createRange(1,0,matcher)
  }

  createRange (min,max,matcher) {
    return RepeatMatcher<#x>{ matcher.copyWithReset(), min, max, 0 }
  }

  copyWithReset () {
    return RepeatMatcher<#x>{ matcher.copyWithReset(), min, max, 0 }
  }

  tryNextMatch (data) (state,data2,branch) {
    if (atMax()) {
      return { MatchState$matchFail(), data, empty }
    }
    { state, data2, branch } <- matcher.tryNextMatch(data)
    if (MatchState$equals(state,MatchState$matchFail())) {
      return _
    }
    if (MatchState$equals(state,MatchState$matchEnd())) {
      ~ incrementMatch()
      if (aboveMin() && !atMax()) {
        RepeatMatcher<#x> branched <- RepeatMatcher<#x>{ matcher, min, max, repetitionCount }
        branch <- LinkedNode<Matcher<#x>>$create(branched,branch)
      } elif (atMax()) {
        state <- MatchState$matchEnd()
      } else {
        state <- MatchState$matchContinue()
      }
    }
  }

  @value incrementMatch () -> ()
  incrementMatch () {
    repetitionCount <- repetitionCount+1
  }

  @value atMax () -> (Bool)
  atMax () {
    return max > 0 && repetitionCount >= max
  }

  @value aboveMin () -> (Bool)
  aboveMin () {
    return repetitionCount >= min
  }

  @value startRepeat () -> ()
  startRepeat () {
    matcher <- matcher.copyWithReset()
  }
}

define SequenceMatcher {
  @value LinkedNode<Matcher<#x>> head
  @value LinkedNode<Matcher<#x>> tail
  @value optional LinkedNode<Matcher<#x>> current

  create (matcher) {
    LinkedNode<Matcher<#x>> node <- LinkedNode<Matcher<#x>>$create(matcher.copyWithReset(),empty)
    return SequenceMatcher<#x>{ node, node, node }
  }

  copyWithReset () {
    optional LinkedNode<Matcher<#x>> head2 <- empty
    optional LinkedNode<Matcher<#x>> tail2 <- empty
    scoped {
      optional LinkedNode<Matcher<#x>> current2 <- head
    } in while (present(current2)) {
      LinkedNode<Matcher<#x>> node <- LinkedNode<Matcher<#x>>$create(require(current2).value().copyWithReset(),empty)
      if (!present(head2)) {
        head2 <- node
        tail2 <- node
      } else {
        ~ require(tail2).setNext(node)
        tail2 <- node
      }
    } update {
      current2 <- require(current2).next()
    }
    return SequenceMatcher<#x>{ require(head2), require(tail2), require(head2) }
  }

  appendMatcher (matcher) {
    LinkedNode<Matcher<#x>> node <- LinkedNode<Matcher<#x>>$create(matcher.copyWithReset(),empty)
    if (!present(head)) {
      head <- node
      tail <- node
      current <- node
    } else {
      ~ tail.setNext(node)
      tail <- node
    }
    return self
  }

  tryNextMatch (data) (state,data2,branch) {
    if (!present(current)) {
      return { MatchState$matchFail(), data, empty }
    }
    { state, data2, branch } <- require(current).value().tryNextMatch(data)
    branch <- extendBranches(branch)
    if (!MatchState$equals(state,MatchState$matchContinue()) &&
        !MatchState$equals(state,MatchState$matchFail())) {
      current <- require(current).next()
      if (MatchState$equals(state,MatchState$matchComplete())) {
        if (present(current)) {
          // Data finished before sequence did.
          state <- MatchState$matchFail()
        } else {
          // Entire sequence is complete.
          state <- MatchState$matchComplete()
        }
      } elif (MatchState$equals(state,MatchState$matchEnd())) {
        if (present(current)) {
          // More sequence and data.
          state <- MatchState$matchContinue()
        } else {
          // Sequence finished before data did.
          state <- MatchState$matchFail()
        }
      }
    }
  }

  @value extendBranches (optional LinkedNode<Matcher<#x>>) -> (optional LinkedNode<Matcher<#x>>)
  extendBranches (branch) (head2) {
    head2 <- empty
    optional LinkedNode<Matcher<#x>> tail2 <- empty
    scoped {
      optional LinkedNode<Matcher<#x>> matcher <- branch
    } in while (present(matcher)) {
      // Extend matcher with the remaining sequence.
      LinkedNode<Matcher<#x>> chained <- LinkedNode<Matcher<#x>>$create(require(matcher).value(),current)
      SequenceMatcher<#x> matcher2 <- SequenceMatcher<#x>{ chained, tail, chained }
      LinkedNode<Matcher<#x>> element <- LinkedNode<Matcher<#x>>$create(matcher2,empty)
      if (!present(head2)) {
        head2 <- element
        tail2 <- element
      } else {
        ~ require(tail2).setNext(element)
        tail2 <- element
      }
    } update {
      matcher <- require(matcher).next()
    }
  }
}

define AlternativeMatcher {
  @value optional LinkedNode<Matcher<#x>> head
  @value optional LinkedNode<Matcher<#x>> tail
  @value optional LinkedNode<Matcher<#x>> current

  create (matcher) {
    LinkedNode<Matcher<#x>> node <- LinkedNode<Matcher<#x>>$create(matcher.copyWithReset(),empty)
    return AlternativeMatcher<#x>{ node, node, node }
  }

  addAlternative (matcher) {
    LinkedNode<Matcher<#x>> node <- LinkedNode<Matcher<#x>>$create(matcher.copyWithReset(),empty)
    if (!present(head)) {
      head <- node
      tail <- node
    } else {
      ~ require(tail).setNext(node)
      tail <- node
    }
    return self
  }

  copyWithReset () {
    optional LinkedNode<Matcher<#x>> head2 <- empty
    optional LinkedNode<Matcher<#x>> tail2 <- empty
    scoped {
      optional LinkedNode<Matcher<#x>> current2 <- head
    } in while (present(current2)) {
      LinkedNode<Matcher<#x>> node <- LinkedNode<Matcher<#x>>$create(require(current2).value().copyWithReset(),empty)
      if (!present(head2)) {
        head2 <- node
        tail2 <- node
      } else {
        ~ require(tail2).setNext(node)
        tail2 <- node
      }
    }
    return AlternativeMatcher<#x>{ head2, tail2, head2 }
  }

  tryNextMatch (data) (state,data2,branch) {
    state <- MatchState$matchFail()
    data2 <- data
    branch <- empty
    optional LinkedNode<Matcher<#x>> head2 <- empty
    optional LinkedNode<Matcher<#x>> tail2 <- empty
    scoped {
      optional LinkedNode<Matcher<#x>> current2 <- current
    } in while (present(current2)) {
      { MatchState state3, #x data3, optional LinkedNode<Matcher<#x>> branch3 } <-
          require(current2).value().tryNextMatch(data)
      if (MatchState$equals(state3,MatchState$matchComplete()) ||
          MatchState$equals(state3,MatchState$matchEnd()) ||
          MatchState$equals(state3,MatchState$matchContinue())) {
        if (MatchState$lessThan(state,state3)) {
          state <- state3
        }
        data2 <- data3 // Assumes that all successes end in the same place.
      }
      if (MatchState$equals(state3,MatchState$matchContinue())) {
        LinkedNode<Matcher<#x>> node <- LinkedNode<Matcher<#x>>$create(require(current2).value(),empty)
        if (!present(head2)) {
          head2 <- node
          tail2 <- node
        } else {
          ~ require(tail2).setNext(node)
          tail2 <- node
        }
        tail2 <- LinkedNode<Matcher<#x>>$appendTail(tail2,branch3)
      }
    } update {
      current2 <- require(current2).next()
    }
    current <- head2
  }
}

define LinkedNode {
  @value optional LinkedNode<#x> parent
  @value #x data

  create (data,parent) {
    return LinkedNode<#x>{ parent, data }
  }

  appendTail (front,back) (tail) {
    tail <- front
    if (!present(tail)) {
      tail <- back
    } else {
      ~ require(tail).setNext(back)
    }
    while (present(tail) && present(require(tail).next())) {
      tail <- require(tail).next()
    }
  }

  value () {
    return data
  }

  next () {
    return parent
  }

  setNext (parent2) {
    parent <- parent2
  }
}
