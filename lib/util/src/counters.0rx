/* -----------------------------------------------------------------------------
Copyright 2021 Kevin P. Barry

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----------------------------------------------------------------------------- */

// Author: Kevin P. Barry [ta0kira@gmail.com]

define Counter {
  zeroIndexed (max) {
    return ForwardCounter.new(max)
  }

  revZeroIndexed (max) {
    return ReverseCounter.new(max)
  }

  unlimited () {
    return UnlimitedCounter.new()
  }
}

concrete ForwardCounter {
  @type new (Int) -> (optional Order<Int>)
}

define ForwardCounter {
  $ReadOnly[limit]$

  refines Order<Int>

  @value Int current
  @value Int limit

  new (max) {
    if (max > 0) {
      return #self{ 0, max }
    } else {
      return empty
    }
  }

  next () {
    if (current < limit-1) {
      current <- current+1
      return self
    } else {
      return empty
    }
  }

  get () {
    return current
  }
}

concrete ReverseCounter {
  @type new (Int) -> (optional Order<Int>)
}

define ReverseCounter {
  refines Order<Int>

  @value Int current

  new (max) {
    if (max > 0) {
      return #self{ max-1 }
    } else {
      return empty
    }
  }

  next () {
    if (current > 0) {
      current <- current-1
      return self
    } else {
      return empty
    }
  }

  get () {
    return current
  }
}

concrete UnlimitedCounter {
  @type new () -> (optional Order<Int>)
}

define UnlimitedCounter {
  refines Order<Int>

  @value Int current

  new () {
    return #self{ 0 }
  }

  next () {
    current <- current+1
    return self
  }

  get () {
    return current
  }
}

define Repeat {
  $ReadOnly[limit,value]$

  refines Order<#x>

  @value #x value
  @value Int current
  @value optional Int limit

  times (value,max) {
    if (max <= 0) {
      return empty
    } else {
      return Repeat<#y>{ value, 0, max }
    }
  }

  unlimited (value) {
    return Repeat<#y>{ value, 0, empty }
  }

  next () {
    if (!present(limit) || current+1 < require(limit)) {
      current <- current+1
      return self
    } else {
      return empty
    }
  }

  get () {
    return value
  }
}

define Ranges {
  min (x,y) (z) {
    z, _ <- minMax<?>(x,y)
  }

  max (x,y) (z) {
    _, z <- minMax<?>(x,y)
  }

  minMax (x,y) {
    // NOTE: Using y < x makes the default x, y when they are equal.
    if (y `#x.lessThan` x) {
      return y, x
    } else {
      return x, y
    }
  }
}
