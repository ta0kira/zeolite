define MatchState {
  @value Int enum
  @value String name
  @category MatchState matchFailVal     <- MatchState{ 0, "matchFail" }
  @category MatchState matchCompleteVal <- MatchState{ 1, "matchComplete" }
  @category MatchState matchContinueVal <- MatchState{ 2, "matchContinue" }

  formatted () {
    return "MatchState$" + name + "()"
  }

  equals (x,y) {
    return x.getEnum() == y.getEnum()
  }

  lessThan (x,y) {
    return x.getEnum() < y.getEnum()
  }

  matchFail () {
    return matchFailVal
  }

  matchComplete () {
    return matchCompleteVal
  }

  matchContinue () {
    return matchContinueVal
  }

  @value getEnum () -> (Int)
  getEnum () {
    return enum
  }
}

define MatchSingle {
  @value #c match

  create (match) {
    return MatchSingle<#c>{ match }
  }

  matchesEmpty () {
    return false
  }

  newMatcher () {
    return MatchSingleMatcher<#c>$create(match)
  }
}

concrete MatchSingleMatcher<#c> {
  #c defines Equals<#c>

  refines Matcher<#c>

  @type create (#c) -> (MatchSingleMatcher<#c>)
}

define MatchSingleMatcher {
  @value #c match
  @value MatchState state

  create (match) {
    return MatchSingleMatcher<#c>{ match, MatchState$matchContinue() }
  }

  matchSatisfied () {
    return MatchState$equals(state,MatchState$matchComplete())
  }

  tryNextMatch (data) {
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      return (state <- MatchState$matchFail())
    }
    if (#c$equals(data,match)) {
      return (state <- MatchState$matchComplete())
    } else {
      return (state <- MatchState$matchFail())
    }
  }
}

define MatchRange {
  @value #c minMatch
  @value #c maxMatch

  create (minMatch,maxMatch) {
    return MatchRange<#c>{ minMatch, maxMatch }
  }

  matchesEmpty () {
    return false
  }

  newMatcher () {
    return MatchRangeMatcher<#c>$create(minMatch,maxMatch)
  }
}

concrete MatchRangeMatcher<#c> {
  #c defines LessThan<#c>

  refines Matcher<#c>

  @type create (#c,#c) -> (MatchRangeMatcher<#c>)
}

define MatchRangeMatcher {
  @value #c minMatch
  @value #c maxMatch
  @value MatchState state

  create (minMatch,maxMatch) {
    return MatchRangeMatcher<#c>{ minMatch, maxMatch, MatchState$matchContinue() }
  }

  matchSatisfied () {
    return MatchState$equals(state,MatchState$matchComplete())
  }

  tryNextMatch (data) {
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      return (state <- MatchState$matchFail())
    }
    if (!#c$lessThan(data,minMatch) && !#c$lessThan(maxMatch,data)) {
      return (state <- MatchState$matchComplete())
    } else {
      return (state <- MatchState$matchFail())
    }
  }
}

define MatchAny {
  create () {
    return MatchAny<#c>{ }
  }

  matchesEmpty () {
    return false
  }

  newMatcher () {
    return MatchAnyMatcher<#c>$create()
  }
}

concrete MatchAnyMatcher<#c> {
  refines Matcher<#c>

  @type create () -> (MatchAnyMatcher<#c>)
}

define MatchAnyMatcher {
  @value MatchState state

  create () {
    return MatchAnyMatcher<#c>{ MatchState$matchContinue() }
  }

  matchSatisfied () {
    return MatchState$equals(state,MatchState$matchComplete())
  }

  tryNextMatch (data) {
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      return (state <- MatchState$matchFail())
    }
    return (state <- MatchState$matchComplete())
  }
}

define MatchRepeat {
  @value MatcherTemplate<#c> template
  @value Int minCount
  @value Int maxCount

  createZeroPlus (template) {
    return createRange(0,0,template)
  }

  createOnePlus (template) {
    return createRange(1,0,template)
  }

  createRange (minCount,maxCount,template) {
    return MatchRepeat<#c>{ template, minCount, maxCount }
  }

  matchesEmpty () {
    return minCount <= 0 || template.matchesEmpty()
  }

  newMatcher () {
    return MatchRepeatMatcher<#c>$create(minCount,maxCount,template)
  }
}

concrete MatchRepeatMatcher<#c> {
  refines Matcher<#c>

  @type create (Int,Int,MatcherTemplate<#c>) -> (MatchRepeatMatcher<#c>)
}

define MatchRepeatMatcher {
  @value MatcherTemplate<#c> template
  @value Matcher<#c> matcher
  @value Int minCount
  @value Int maxCount // 0 means unlimited.
  @value Int repetitionCount
  @value MatchState lastState

  create (minCount,maxCount,template) {
    return MatchRepeatMatcher<#c>{ template, template.newMatcher(), minCount,
                                   maxCount, 0, MatchState$matchComplete() }
  }

  matchSatisfied () {
    if (MatchState$equals(lastState,MatchState$matchFail())) {
      return false
    }
    if (MatchState$equals(lastState,MatchState$matchContinue()) &&
        repetitionCount+1 >= minCount && matcher.matchSatisfied()) {
      // The rest of the current repetition can be ignored.
      return true
    }
    if (MatchState$equals(lastState,MatchState$matchComplete()) &&
        repetitionCount >= minCount) {
      return true
    }
    return false
  }

  tryNextMatch (data) (state) {
    if (atMax() || (MatchState$equals(lastState,MatchState$matchFail()))) {
      return MatchState$matchFail()
    }
    state <- (lastState <- matcher.tryNextMatch(data))
    if (MatchState$equals(state,MatchState$matchComplete())) {
      ~ incrementMatch()
      ~ startRepeat()
      if (atMax()) {
        state <- MatchState$matchComplete()
      } else {
        state <- MatchState$matchContinue()
      }
    }
  }

  @value incrementMatch () -> ()
  incrementMatch () {
    repetitionCount <- repetitionCount+1
  }

  @value atMax () -> (Bool)
  atMax () {
    return maxCount > 0 && repetitionCount >= maxCount
  }

  @value startRepeat () -> ()
  startRepeat () {
    matcher <- template.newMatcher()
  }
}

define MatchBranches {
  @value MatchBrancherTemplate<#c> template

  create (template) {
    return MatchBranches<#c>{ template }
  }

  matchesEmpty () {
    return template.matchesEmpty()
  }

  newMatcher () {
    return MatchBranchesMatcher<#c>$create(template.newBrancher())
  }
}

concrete MatchBranchesMatcher<#c> {
  refines Matcher<#c>

  @type create (MatchBrancher<#c>) -> (MatchBranchesMatcher<#c>)
}

define MatchBranchesMatcher {
  @value optional ReadSequence<MatchBrancher<#c>> branches
  @value Bool complete

  create (brancher) {
    return MatchBranchesMatcher<#c>{ LinkedNode<MatchBrancher<#c>>$create(brancher,empty), false }
  }

  matchSatisfied () {
    if (complete) {
      return true
    }
    scoped {
      optional ReadSequence<MatchBrancher<#c>> current <- branches
    } in while (present(current)) {
      if (require(current).value().matchSatisfied()) {
        return true
      }
    } update {
      current <- require(current).next()
    }
    return false
  }

  tryNextMatch (data) (state) {
    state <- MatchState$matchFail()
    scoped {
      optional ReadSequence<MatchBrancher<#c>> current <- branches
      branches <- empty
    } in while (present(current)) {
      { MatchState state2, optional ReadSequence<MatchBrancher<#c>> branches2 } <-
          require(current).value().tryBranches(data)
      if (MatchState$lessThan(state,state2)) {
        state <- state2
      }
      scoped {
        optional ReadSequence<MatchBrancher<#c>> current2 <- branches2
      } in while (present(current2)) {
        branches <- LinkedNode<MatchBrancher<#c>>$create(require(current2).value(),branches)
      } update {
        current2 <- require(current2).next()
      }
    } update {
      current <- require(current).next()
    }
    complete <- MatchState$equals(state,MatchState$matchComplete())
  }
}

define BranchSequence {
  @value optional ReadSequence<MatcherTemplate<#c>> sequence

  create (sequence) {
    return BranchSequence<#c>{ sequence }
  }

  matchesEmpty () {
    scoped {
      optional ReadSequence<MatcherTemplate<#c>> current <- sequence
    } in while (present(current)) {
      if (!require(current).value().matchesEmpty()) {
        return false
      }
    } update {
      current <- require(current).next()
    }
    return true
  }

  newBrancher () {
    return BranchSequenceMatcher<#c>$create(sequence)
  }
}

concrete BranchSequenceMatcher<#c> {
  refines MatchBrancher<#c>

  @type create (optional ReadSequence<MatcherTemplate<#c>>) -> (BranchSequenceMatcher<#c>)
  @value tryBranches (#c) -> (MatchState,optional ReadSequence<BranchSequenceMatcher<#c>>)
}

define BranchSequenceMatcher {
  @value optional Matcher<#c> continued
  @value optional ReadSequence<MatcherTemplate<#c>> sequence
  @value Bool consumed

  create (sequence) {
    return BranchSequenceMatcher<#c>{ empty, sequence, false }
  }

  matchSatisfied () {
    if (consumed) {
      return false
    }
    if (present(continued) && !require(continued).matchSatisfied()) {
      return false
    }
    scoped {
      optional ReadSequence<MatcherTemplate<#c>> current <- sequence
    } in while (present(current)) {
      if (!require(current).value().matchesEmpty()) {
        return false
      }
    } update {
      current <- require(current).next()
    }
    return true
  }

  tryBranches (data) (state,branches) {
    branches <- empty
    state <- MatchState$matchFail()
    if (consumed) {
      return _
    }
    while (present(continued) || present(sequence)) {
      if (!present(continued)) {
        continued <- require(sequence).value().newMatcher()
        sequence <- require(sequence).next()
      }
      Bool complete <- require(continued).matchSatisfied()
      MatchState state2 <- require(continued).tryNextMatch(data)
      if (MatchState$equals(state2,MatchState$matchComplete())) {
        if (present(sequence)) {
          // Add a branch to continue this sequence.
          branches <- LinkedNode<BranchSequenceMatcher<#c>>$create(
              BranchSequenceMatcher<#c>{ empty, sequence, false },branches)
          state2 <- MatchState$matchContinue()
        }
      } elif (MatchState$equals(state2,MatchState$matchContinue())) {
        // Add a branch to continue this sequence.
        branches <- LinkedNode<BranchSequenceMatcher<#c>>$create(
            BranchSequenceMatcher<#c>{ continued, sequence, false },branches)
      }
      if (MatchState$lessThan(state,state2)) {
        // NOTE: state2 might be updated above!
        state <- state2
      }
      if (!complete) {
        // The matcher can't be skipped => no more branching is possible.
        break
      }
    } update {
      continued <- empty
    }
    consumed <- true
  }
}

define LinkedNode {
  @value optional ReadSequence<#x> parent
  @value #x data

  create (data,parent) {
    return LinkedNode<#x>{ parent, data }
  }

  value () {
    return data
  }

  next () {
    return parent
  }
}
