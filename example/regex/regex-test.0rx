define RegexTest {
  runTests () {
    ~ testMatchSingleMatch()
    ~ testMatchSingleNonMatch()

    ~ testMatchRangeMatch()
    ~ testMatchRangeNonMatch()

    ~ testMatchAnyMatch()

    ~ testRepeatMatcherMatch()
    ~ testRepeatMatcherNested()
    ~ testRepeatMatcherNonMatch()

    ~ testSequenceMatcherMatch()
    ~ testSequenceMatcherNonMatch()
    ~ testSequenceMatcherBranch()
    ~ testSequenceMatcherNestedBranch()
    ~ testSequenceMatcherSkipFailedEmpty()
    ~ testSequenceMatcherEndBranch()

    ~ testBranchMatcherMatch()
    ~ testBranchMatcherNonMatch()
  }

  @type testMatchSingleMatch () -> ()
  testMatchSingleMatch () {
    Matcher<Char> matcher <- MatchSingle<Char>$create('x')

    MatchState state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }

    // Should only match once.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }

    // Should match again after reset.
    matcher <- matcher.copyWithReset()
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
  }

  @type testMatchSingleNonMatch () -> ()
  testMatchSingleNonMatch () {
    Matcher<Char> matcher <- MatchSingle<Char>$create('x')

    MatchState state <- matcher.tryNextMatch('y')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }

    // Should keep failing to match.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }
  }

  @type testMatchRangeMatch () -> ()
  testMatchRangeMatch () {
    Matcher<Char> matcher <- MatchRange<Char>$create('w','y')

    MatchState state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }

    // Should only match once.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }

    // Should match again after reset.
    matcher <- matcher.copyWithReset()
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
  }

  @type testMatchRangeNonMatch () -> ()
  testMatchRangeNonMatch () {
    Matcher<Char> matcher <- MatchRange<Char>$create('w','y')

    MatchState state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }

    // Should keep failing to match.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }
  }

  @type testMatchAnyMatch () -> ()
  testMatchAnyMatch () {
    Matcher<Char> matcher <- MatchAny<Char>$create()

    MatchState state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }

    // Should only match once.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }

    // Should match again after reset.
    matcher <- matcher.copyWithReset()
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
  }

  @type testRepeatMatcherMatch () -> ()
  testRepeatMatcherMatch () {
    Matcher<Char> matcher <-
        RepeatMatcher<Char>$createRange(2,3,MatchRange<Char>$create('w','y'))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Second character.
    state <- matcher.tryNextMatch('y')
    if (!MatchState$equals(state,MatchState$matchBranch())) {
      ~ fail(state)
    }
    if (!matcher.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }

    // Third character.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }

    // Reset to reuse the matcher.
    matcher <- matcher.copyWithReset()

    // Fourth character.
    state <- matcher.tryNextMatch('w')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Fifth character.
    state <- matcher.tryNextMatch('w')
    if (!MatchState$equals(state,MatchState$matchBranch())) {
      ~ fail(state)
    }
  }

  @type testRepeatMatcherNested () -> ()
  testRepeatMatcherNested () {
    Matcher<Char> matcher <-
        RepeatMatcher<Char>$createZeroPlus(
            RepeatMatcher<Char>$createZeroPlus(MatchSingle<Char>$create('x')))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchBranch())) {
      ~ fail(state)
    }

    // Second character.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchBranch())) {
      ~ fail(state)
    }

    // Third character.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchBranch())) {
      ~ fail(state)
    }
  }

  @type testRepeatMatcherNonMatch () -> ()
  testRepeatMatcherNonMatch () {
    Matcher<Char> matcher <-
        RepeatMatcher<Char>$createRange(2,3,MatchRange<Char>$create('w','y'))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }

    // Second character.
    state <- matcher.tryNextMatch('q')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }

    // Should keep failing to match.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }
  }

  @type testSequenceMatcherMatch () -> ()
  testSequenceMatcherMatch () {
    SequenceMatcher<Char> matcher <-
        SequenceMatcher<Char>$create(
            LinkedNode<Matcher<Char>>$create(MatchRange<Char>$create('w','y'),
                LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('a'),empty)))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('x')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Second character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (!matcher.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }

    // Reset to reuse the matcher.
    matcher <- matcher.copyWithReset()

    // Third character.
    state <- matcher.tryNextMatch('y')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }

    // Fourth character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
  }

  @type testSequenceMatcherNonMatch () -> ()
  testSequenceMatcherNonMatch () {
    SequenceMatcher<Char> matcher <-
        SequenceMatcher<Char>$create(
            LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('a'),
                LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('b'),empty)))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Second character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Should keep failing to match.
    state <- matcher.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }
  }

  @type testSequenceMatcherBranch () -> ()
  testSequenceMatcherBranch () {
    SequenceMatcher<Char> matcher <-
        SequenceMatcher<Char>$create(
            LinkedNode<Matcher<Char>>$create(RepeatMatcher<Char>$createRange(1,2,MatchSingle<Char>$create('a')),
                LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('b'),empty)))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    // The RepeatMatcher should branch.
    if (!present(matcher.getBranch())) {
      ~ fail("branch missing")
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    SequenceMatcher<Char> branch <- require(matcher.getBranch())

    // Second character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Third character.
    state <- matcher.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (!matcher.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }

    // Second character in branch.
    state <- branch.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
    if (present(branch.getBranch())) {
      ~ fail("branch present")
    }
    if (!branch.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }
  }

  @type testSequenceMatcherNestedBranch () -> ()
  testSequenceMatcherNestedBranch () {
    Matcher<Char> matcher0 <-
        SequenceMatcher<Char>$create(
            LinkedNode<Matcher<Char>>$create(RepeatMatcher<Char>$createRange(1,2,MatchSingle<Char>$create('a')),empty))
    SequenceMatcher<Char> matcher <-
        SequenceMatcher<Char>$create(
            LinkedNode<Matcher<Char>>$create(matcher0,
                LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('b'),empty)))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    // The RepeatMatcher should branch.
    if (!present(matcher.getBranch())) {
      ~ fail("branch missing")
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    SequenceMatcher<Char> branch <- require(matcher.getBranch())

    // Second character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Third character.
    state <- matcher.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (!matcher.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }

    // Second character in branch.
    state <- branch.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
    if (present(branch.getBranch())) {
      ~ fail("branch present")
    }
    if (!branch.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }
  }

  @type testSequenceMatcherSkipFailedEmpty () -> ()
  testSequenceMatcherSkipFailedEmpty () {
    SequenceMatcher<Char> matcher <-
        SequenceMatcher<Char>$create(
            LinkedNode<Matcher<Char>>$create(RepeatMatcher<Char>$createZeroPlus(MatchSingle<Char>$create('a')),
                LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('b'),empty)))

    MatchState state <- MatchState$matchFail()

    // First character skips over 'a*'.
    state <- matcher.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (!matcher.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }
  }

  @type testSequenceMatcherEndBranch () -> ()
  testSequenceMatcherEndBranch () {
    SequenceMatcher<Char> matcher <-
        SequenceMatcher<Char>$create(
            LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('a'),
                LinkedNode<Matcher<Char>>$create(
                    RepeatMatcher<Char>$createOnePlus(MatchSingle<Char>$create('b')),empty)))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Second character.
    state <- matcher.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchBranch())) {
      ~ fail(state)
    }
    if (present(matcher.getBranch())) {
      ~ fail("branch present")
    }
    if (!matcher.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }
  }

  @type testBranchMatcherMatch () -> ()
  testBranchMatcherMatch () {
    BranchMatcher<Char> matcher <-
        BranchMatcher<Char>$create(
            SequenceMatcher<Char>$create(
                LinkedNode<Matcher<Char>>$create(RepeatMatcher<Char>$createZeroPlus(MatchSingle<Char>$create('a')),
                    LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('b'),empty))))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Second character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Third character.
    state <- matcher.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
    if (!matcher.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }

    // Reset to reuse the matcher.
    matcher <- matcher.copyWithReset()

    // Fourth character.
    state <- matcher.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchComplete())) {
      ~ fail(state)
    }
    if (!matcher.matchesEmpty()) {
      ~ fail("doesn't match empty")
    }
  }

  @type testBranchMatcherNonMatch () -> ()
  testBranchMatcherNonMatch () {
    BranchMatcher<Char> matcher <-
        BranchMatcher<Char>$create(
            SequenceMatcher<Char>$create(
                LinkedNode<Matcher<Char>>$create(RepeatMatcher<Char>$createZeroPlus(MatchSingle<Char>$create('a')),
                    LinkedNode<Matcher<Char>>$create(MatchSingle<Char>$create('b'),empty))))

    MatchState state <- MatchState$matchFail()

    // First character.
    state <- matcher.tryNextMatch('a')
    if (!MatchState$equals(state,MatchState$matchContinue())) {
      ~ fail(state)
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Second character.
    state <- matcher.tryNextMatch('c')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }
    if (matcher.matchesEmpty()) {
      ~ fail("matches empty")
    }

    // Should keep failing to match.
    state <- matcher.tryNextMatch('b')
    if (!MatchState$equals(state,MatchState$matchFail())) {
      ~ fail(state)
    }
  }
}
