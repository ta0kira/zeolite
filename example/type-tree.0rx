define TypeTree {
  @value Tree<TypeKey<any>,HiddenType> tree

  new () {
    return TypeTree { Tree<TypeKey<any>,HiddenType>$new() }
  }

  set (k,v) {
    ~ tree.set(k,HiddenType$create<#x>(k,v))
    return self
  }

  remove (k) {
    ~ tree.remove(k)
    return self
  }

  get (k) {
    scoped {
      optional HiddenType value <- tree.get(k)
    } in if (present(value)) {
      return require(value).check<#x>(k)
    } else {
      return empty
    }
  }
}

define TypeKey {
  @category Int counter <- 0
  @value Int index

  new () {
    return TypeKey<#x>{ (counter <- counter+1) }
  }

  lessThan (l,r) {
    return l.get() < r.get()
  }

  equals (l,r) {
    return l.get() == r.get()
  }

  @value get () -> (Int)
  get () {
    return index
  }
}

concrete HiddenType {
  @type create<#y> (TypeKey<#y>,#y) -> (HiddenType)
  @value check<#y> (TypeKey<#y>) -> (optional #y)
}

define HiddenType {
  types<#x> {}
  @value TypeKey<#x> key
  @value #x value

  create (k,v) {
    return HiddenType { types<#y>, k, v }
  }

  check (k) {
    if (TypeKey<any>$equals(key,k)) {
      return reduce<#x,#y>(value)
    } else {
      return empty
    }
  }
}
