define TypeTree {
  @value Tree<TypeKey<any>,LockedType<all>> tree

  new () {
    return TypeTree{ Tree<TypeKey<any>,LockedType<all>>$new() }
  }

  set (k,v) {
    ~ tree.set(k,LockedType<#x>$create(k,v))
    return self
  }

  remove (k) {
    ~ tree.remove(k)
    return self
  }

  get (k) {
    scoped {
      optional LockedType<all> value <- tree.get(k)
    } in if (present(value)) {
      return require(value).check<#x>(k)
    } else {
      return empty
    }
  }
}

define TypeKey {
  @category Int counter <- 0
  @value Int index

  new () {
    return TypeKey<#x>{ (counter <- counter+1) }
  }

  lessThan (l,r) {
    return l.get() < r.get()
  }

  equals (l,r) {
    return l.get() == r.get()
  }

  @value get () -> (Int)
  get () {
    return index
  }
}

concrete LockedType<#x|> {
  @type create (TypeKey<#x>,#x) -> (LockedType<#x>)
  @value check<#y> (TypeKey<#y>) -> (optional #y)
}

define LockedType {
  @value TypeKey<#x> key
  @value #x value

  create (k,v) {
    return LockedType<#x>{ k, v }
  }

  check (k) {
    if (TypeKey<any>$equals(key,k)) {
      return reduce<#x,#y>(value)
    } else {
      return empty
    }
  }
}
