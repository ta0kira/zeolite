/* -----------------------------------------------------------------------------
Copyright 2020 Kevin P. Barry

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----------------------------------------------------------------------------- */

// Author: Kevin P. Barry [ta0kira@gmail.com]

testcase "converted call" {
  success
}

unittest test {
  Value value <- Value.create()
  \ value.Base.call()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}


testcase "converted call bad type" {
  error
  require "Base"
}

unittest test {
  Value value <- Value.create()
  \ value.Base.call()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  @value call () -> ()
  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}


testcase "call from union" {
  error
  require "\[Base\|Value\]"
}

unittest test {
  [Base|Value] value <- Value.create()
  \ value.call()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}


testcase "call from union with conversion" {
  success
}

unittest test {
  [Base|Value] value <- Value.create()
  \ value.Base.call()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}


testcase "call from intersect" {
  success
}

unittest test {
  [Base1&Base2] value <- Value.create()
  \ value.call()
}

@value interface Base1 {
  call () -> ()
}

@value interface Base2 {}

concrete Value {
  refines Base1
  refines Base2

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}


testcase "call from intersect with conversion" {
  success
}

unittest test {
  [Base1&Base2] value <- Value.create()
  \ value.Base1.call()
}

@value interface Base1 {
  call () -> ()
}

@value interface Base2 {}

concrete Value {
  refines Base1
  refines Base2

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}


testcase "call from intersect with conversion" {
  success
}

unittest test {
  [Base1&Base2] value <- Value.create()
  \ value.Base1.call()
}

@value interface Base1 {
  call () -> ()
}

@value interface Base2 {}

concrete Value {
  refines Base1
  refines Base2

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}


testcase "call from param type" {
  success
}

unittest test {
  \ Test.check<Value>()
}

@type interface Base {
  call () -> ()
}

concrete Value {
  defines Base
}

define Value {
  call () {}
}

concrete Test {
  @type check<#x>
    #x defines Base
  () -> ()
}

define Test {
  check () {
    \ #x.call()
  }
}


testcase "call from bad param type" {
  error
  require "call.+param #x"
}

@type interface Base {
  call () -> ()
}

define Test {
  @type check<#x>
  () -> ()
  check () {
    \ #x.call()
  }
}

concrete Test {}


testcase "call from param value" {
  success
}

unittest test {
  Value value <- Value.create()
  \ Test.check<Value>(value)
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

concrete Test {
  @type check<#x>
    #x requires Base
  (#x) -> ()
}

define Test {
  check (value) {
    \ value.call()
  }
}


testcase "call from bad param value" {
  error
  require "call.+param #x"
}

@value interface Base {
  call () -> ()
}

define Test {
  @type check<#x>
  (#x) -> ()
  check (value) {
    \ value.call()
  }
}

concrete Test {}


testcase "convert arg" {
  success
}

unittest test {
  \ Test.convert(Value.create()).call()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

concrete Test {
  @type convert (Value) -> (Base)
}

define Test {
  convert (value) {
    return value
  }
}


testcase "bad convert arg" {
  error
  require "does not refine Value"
}

@value interface Base {}

concrete Value {}

define Value {}

define Test {
  @type convert (Base) -> (Value)
  convert (value) {
    return value
  }
}

concrete Test {}


testcase "bad instance in param" {
  error
  require "Test"
  require "define"
  require "Equals"
}

unittest test {
  \ Call.call<Value<Test>>()
}

concrete Value<#x> {
  #x defines Equals<#x>
}

define Value {}

concrete Call {
  @type call<#x> () -> ()
}

define Call {
  call () {}
}


testcase "overwrite arg" {
  error
  require "arg"
}

define Test {
  @type call (Int) -> ()
  call (arg) {
    arg <- 2
  }
}

concrete Test {}


testcase "self in @category function" {
  error
  require "self"
}

define Test {
  @category call () -> ()
  call () {
    Test value <- self
  }
}

concrete Test {}
