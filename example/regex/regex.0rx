define MatchState {
  @value Int enum
  @value String name
  @category MatchState matchFailVal     <- MatchState{ 0, "matchFail" }
  @category MatchState matchContinueVal <- MatchState{ 1, "matchContinue" }
  @category MatchState matchCompleteVal <- MatchState{ 2, "matchComplete" }

  formatted () {
    return "MatchState$" + name + "()"
  }

  equals (x,y) {
    return x.getEnum() == y.getEnum()
  }

  lessThan (x,y) {
    return x.getEnum() < y.getEnum()
  }

  matchFail () {
    return matchFailVal
  }

  matchContinue () {
    return matchContinueVal
  }

  matchComplete () {
    return matchCompleteVal
  }

  @value getEnum () -> (Int)
  getEnum () {
    return enum
  }
}

define MatchSingle {
  @value #c match
  @value MatchState state

  create (match) {
    return MatchSingle<#c>{ match, MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchSingle<#c>{ match, MatchState$matchContinue() }
  }

  matchesEmpty () {
    return false
  }

  tryNextMatch (data) (state2,branches) {
    state2 <- MatchState$matchFail()
    branches <- empty
    if (MatchState$equals(state,MatchState$matchContinue())) {
      if (#c$equals(data,match)) {
        state2 <- MatchState$matchComplete()
      }
    }
    state <- state2
  }
}

define MatchRange {
  @value #c matchMin
  @value #c matchMax
  @value MatchState state

  create (matchMin,matchMax) {
    return MatchRange<#c>{ matchMin, matchMax, MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchRange<#c>{ matchMin, matchMax, MatchState$matchContinue() }
  }

  matchesEmpty () {
    return false
  }

  tryNextMatch (data) (state2,branches) {
    state2 <- MatchState$matchFail()
    branches <- empty
    if (MatchState$equals(state,MatchState$matchContinue())) {
      if (!#c$lessThan(data,matchMin) && !#c$lessThan(matchMax,data)) {
        state2 <- MatchState$matchComplete()
      }
    }
    state <- state2
  }
}

define MatchAny {
  @value MatchState state

  create () {
    return MatchAny<#c>{ MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchAny<#c>{ MatchState$matchContinue() }
  }

  matchesEmpty () {
    return false
  }

  tryNextMatch (_) (state2,branches) {
    state2 <- MatchState$matchFail()
    branches <- empty
    if (MatchState$equals(state,MatchState$matchContinue())) {
      state2 <- MatchState$matchComplete()
    }
    state <- state2
  }
}

define RepeatMatcher {
  @value Matcher<#c> matcher
  @value Int min
  @value Int max // 0 means unlimited.
  @value Int repetitionCount
  @value Bool failed

  createZeroPlus (matcher) {
    return createRange(0,0,matcher)
  }

  createOnePlus (matcher) {
    return createRange(1,0,matcher)
  }

  createRange (min,max,matcher) {
    return RepeatMatcher<#c>{ matcher, min, max, 0, false }
  }

  copyWithReset () {
    return RepeatMatcher<#c>{ matcher.copyWithReset(), min, max, 0, false }
  }

  matchesEmpty () {
    return reachedMin()
  }

  tryNextMatch (data) (state,branches) {
    if (atMax() || failed) {
      return { MatchState$matchFail(), empty }
    }
    { state, branches } <- matcher.tryNextMatch(data)
    if (MatchState$equals(state,MatchState$matchComplete())) {
      ~ incrementMatch()
      ~ startRepeat()
      if (reachedMin()) {
        state <- MatchState$matchComplete()
        if (!atMax()) {
          // Add a new branch to continue optional matching.
          branches <- LinkedNode<Matcher<#c>>$create(self,branches)
        }
      } else {
        state <- MatchState$matchContinue()
      }
    } elif (MatchState$equals(state,MatchState$matchFail())) {
      failed <- true
    }
  }

  @value incrementMatch () -> ()
  incrementMatch () {
    repetitionCount <- repetitionCount+1
  }

  @value atMax () -> (Bool)
  atMax () {
    return max > 0 && repetitionCount >= max
  }

  @value reachedMin () -> (Bool)
  reachedMin () {
    return repetitionCount >= min
  }

  @value startRepeat () -> ()
  startRepeat () {
    matcher <- matcher.copyWithReset()
  }
}

define SequenceMatcher {
  @value LinkedNode<Matcher<#c>> head
  @value LinkedNode<Matcher<#c>> tail
  @value optional ReadSequence<Matcher<#c>> current

  create (matcher) {
    LinkedNode<Matcher<#c>> node <- LinkedNode<Matcher<#c>>$create(matcher,empty)
    return SequenceMatcher<#c>{ node, node, node }
  }

  matchesEmpty () {
    scoped {
      optional ReadSequence<Matcher<#c>> current2 <- current
    } in while (present(current2)) {
      if (!require(current2).value().matchesEmpty()) {
        return false
      }
    } update {
      current2 <- require(current2).next()
    }
    return true
  }

  copyWithReset () {
    { optional LinkedNode<Matcher<#c>> head2,
      optional LinkedNode<Matcher<#c>> tail2 } <- copySequence(head)
    return SequenceMatcher<#c>{ require(head2), require(tail2), head2 }
  }

  appendMatcher (matcher) {
    LinkedNode<Matcher<#c>> node <- LinkedNode<Matcher<#c>>$create(matcher,empty)
    if (!present(head)) {
      head <- node
      tail <- node
      current <- node
    } else {
      ~ tail.setNext(node)
      tail <- node
    }
    return self
  }

  tryNextMatch (data) (state,branches) {
    if (!present(current)) {
      return { MatchState$matchFail(), empty }
    }
    { state, branches } <- require(current).value().tryNextMatch(data)
    if (MatchState$equals(state,MatchState$matchComplete())) {
      current <- require(current).next()
      branches <- extendBranches(branches)
      if (!matchesEmpty()) {
        state <- MatchState$matchContinue()
      } elif (present(current)) {
        // Add a new branch to continue optional matching.
        branches <- LinkedNode<Matcher<#c>>$create(self,branches)
      }
    } else {
      branches <- empty
    }
  }

  @value extendBranches (optional ReadSequence<Matcher<#c>>) -> (optional ReadSequence<Matcher<#c>>)
  extendBranches (branches) (head2) {
    if (!present(current)) {
      return branches
    }
    head2 <- empty
    scoped {
      optional LinkedNode<Matcher<#c>> tail2 <- empty
      optional ReadSequence<Matcher<#c>> current2 <- branches
    } in while (present(current2)) {
      SequenceMatcher<#c> extended <- extendSingleBranch(require(current2).value())
      LinkedNode<Matcher<#c>> node <- LinkedNode<Matcher<#c>>$create(extended,empty)
      if (!present(head2)) {
        head2 <- node
        tail2 <- node
      } else {
        ~ require(tail2).setNext(node)
        tail2 <- node
      }
    } update {
      current2 <- require(current2).next()
    }
  }

  @value extendSingleBranch (Matcher<#c>) -> (SequenceMatcher<#c>)
  extendSingleBranch (branch) {
    { optional LinkedNode<Matcher<#c>> head2,
      optional LinkedNode<Matcher<#c>> tail2 } <- copySequence(current)
    // NOTE: Don't copyWithReset() branch!
    head2 <- LinkedNode<Matcher<#c>>$create(branch,head2)
    if (!present(tail2)) {
      tail2 <- head2
    }
    return SequenceMatcher<#c>{ require(head2), require(tail2), head2 }
  }

  @type copySequence
  (optional ReadSequence<Matcher<#c>>) ->
  (optional LinkedNode<Matcher<#c>>,optional LinkedNode<Matcher<#c>>)
  copySequence (head) (head2,tail2) {
    head2 <- empty
    tail2 <- empty
    scoped {
      optional ReadSequence<Matcher<#c>> current <- head
    } in while (present(current)) {
      LinkedNode<Matcher<#c>> node <-
          LinkedNode<Matcher<#c>>$create(require(current).value().copyWithReset(),empty)
      if (!present(head2)) {
        head2 <- node
        tail2 <- node
      } else {
        ~ require(tail2).setNext(node)
        tail2 <- node
      }
    } update {
      current <- require(current).next()
    }
  }
}

concrete LinkedNode<#x> {
  refines ReadSequence<#x>

  @type create (#x,optional ReadSequence<#x>) -> (LinkedNode<#x>)
  @value setNext(optional ReadSequence<#x>) -> ()
}

define LinkedNode {
  @value optional ReadSequence<#x> parent
  @value #x data

  create (data,parent) {
    return LinkedNode<#x>{ parent, data }
  }

  value () {
    return data
  }

  next () {
    return parent
  }

  setNext (parent2) {
    parent <- parent2
  }
}
