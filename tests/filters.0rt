/* -----------------------------------------------------------------------------
Copyright 2020 Kevin P. Barry

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----------------------------------------------------------------------------- */

// Author: Kevin P. Barry [ta0kira@gmail.com]

testcase "external filter not applied in @category" {
  success
}

unittest test {
  \ Test.run()
}

concrete Value<#x> {
  #x defines LessThan<#x>

  @category something<#x> () -> ()
}

define Value {
  something () {}
}

define Test {
  run () {
    \ Value:something<Bool>()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "category param bounded on both sides" {
  error
  require compiler "#x.+bound"
  require compiler "[Uu]pper.+ \[Type1&Type2\]"
  require compiler "[Ll]ower.+ \[Type3\|Type4\]"
}

@value interface Type1 {}

@value interface Type2 {}

@value interface Type3 {}

@value interface Type4 {}

@value interface Value<#x> {
  #x requires Type1
  #x requires Type2
  #x allows   Type3
  #x allows   Type4
}


testcase "implicit bound from reversing another filter" {
  error
  require compiler "#x.+bound"
  require compiler "[Uu]pper.+ Type"
  require compiler "[Ll]ower.+ #y"
}

@value interface Type {}

@value interface Value<#x,#y> {
  #x requires Type
  #y requires #x
}


testcase "defines filter is not an upper bound" {
  success
}

unittest test {
  \ empty
}

@type interface Type1 {}

@value interface Type2 {}

@value interface Value<#x> {
  #x defines Type1
  #x allows  Type2
}


testcase "defines filter is not a lower bound" {
  success
}

unittest test {
  \ empty
}

@type interface Type1 {}

@value interface Type2 {}

@value interface Value<#x> {
  #x defines  Type1
  #x requires Type2
}


testcase "function param bounded on both sides" {
  error
  require compiler "#x.+bound"
}

@value interface Type1 {}

@value interface Type2 {}

@value interface Value {
  call<#x>
    #x requires Type1
    #x allows   Type2
  () -> ()
}
