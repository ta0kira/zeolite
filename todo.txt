Roughly in order of execution:

- Compile implementations, e.g., type-check and resolve symbols.

- Rewrite and test C++ base.
- Output implementations.

- Integration tests for full compilation.

- Implement module system in compiler.
- Create modules for "standard library" stuff, e.g., Queue.
- Streamline compilation process.
- Streamline compiler installation.


Supported in implementation, roughly in order of simplicity+importance:

- function arguments and returns (inside function)
- value assignment
- internal data
- value initialization

- variable creation
- calling functions (outside function)
- variable init is always required (even weak/optional?)
- ignoring return needs to be explicit (e.g., _ = f())?

- inference of expression type
- bool/string/int literals
- bool/string/int expressions
- optional
- skip/present/require
- weak/strong

- while
- if/elif/else

- category/instance/value function calls
- named return values
- receiving multiple return values
- function calls with explicit type args
- explicit type conversion for function call (to avoid ambiguity)

- internal type variables (value only)
- no access to internal variables if they have variance
- no access to internal types if any constraint uses a variant param

- scoped, e.g., scoped { ... } while { ... }

- reduce, e.g., reduce<x,y>(value)
