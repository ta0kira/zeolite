define MatchState {
  @value Int enum
  @value String name
  @category MatchState matchFailVal     <- MatchState{ 0, "matchFail" }
  @category MatchState matchContinueVal <- MatchState{ 1, "matchContinue" }
  @category MatchState matchCompleteVal <- MatchState{ 2, "matchComplete" }
  @category MatchState matchBranchVal   <- MatchState{ 3, "matchBranch" }

  formatted () {
    return "MatchState$" + name + "()"
  }

  equals (x,y) {
    return x.getEnum() == y.getEnum()
  }

  matchFail () {
    return matchFailVal
  }

  matchContinue () {
    return matchContinueVal
  }

  matchComplete () {
    return matchCompleteVal
  }

  matchBranch () {
    return matchBranchVal
  }

  @value getEnum () -> (Int)
  getEnum () {
    return enum
  }
}

define MatchSingle {
  @value #c match
  @value MatchState state

  create (match) {
    return MatchSingle<#c>{ match, MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchSingle<#c>{ match, MatchState$matchContinue() }
  }

  matchesEmpty () {
    return false
  }

  tryNextMatch (data) (state2) {
    state2 <- MatchState$matchFail()
    if (MatchState$equals(state,MatchState$matchContinue())) {
      if (#c$equals(data,match)) {
        state2 <- MatchState$matchComplete()
      }
    }
    state <- state2
  }
}

define MatchRange {
  @value #c matchMin
  @value #c matchMax
  @value MatchState state

  create (matchMin,matchMax) {
    return MatchRange<#c>{ matchMin, matchMax, MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchRange<#c>{ matchMin, matchMax, MatchState$matchContinue() }
  }

  matchesEmpty () {
    return false
  }

  tryNextMatch (data) (state2) {
    state2 <- MatchState$matchFail()
    if (MatchState$equals(state,MatchState$matchContinue())) {
      if (!#c$lessThan(data,matchMin) && !#c$lessThan(matchMax,data)) {
        state2 <- MatchState$matchComplete()
      }
    }
    state <- state2
  }
}

define MatchAny {
  @value MatchState state

  create () {
    return MatchAny<#c>{ MatchState$matchContinue() }
  }

  copyWithReset () {
    return MatchAny<#c>{ MatchState$matchContinue() }
  }

  matchesEmpty () {
    return false
  }

  tryNextMatch (_) (state2) {
    state2 <- MatchState$matchFail()
    if (MatchState$equals(state,MatchState$matchContinue())) {
      state2 <- MatchState$matchComplete()
    }
    state <- state2
  }
}

define RepeatMatcher {
  @value Matcher<#c> matcher
  @value Int min
  @value Int max // 0 means unlimited.
  @value Int repetitionCount
  @value Bool failed

  createZeroPlus (matcher) {
    return createRange(0,0,matcher)
  }

  createOnePlus (matcher) {
    return createRange(1,0,matcher)
  }

  createRange (min,max,matcher) {
    return RepeatMatcher<#c>{ matcher, min, max, 0, false }
  }

  copyWithReset () {
    return RepeatMatcher<#c>{ matcher.copyWithReset(), min, max, 0, false }
  }

  matchesEmpty () {
    return reachedMin()
  }

  tryNextMatch (data) (state) {
    if (atMax() || failed) {
      return MatchState$matchFail()
    }
    state <- matcher.tryNextMatch(data)
    // matchContinue() is passed on.
    if (MatchState$equals(state,MatchState$matchComplete()) ||
        MatchState$equals(state,MatchState$matchBranch())) {
      ~ incrementMatch()
      ~ startRepeat()
      if (reachedMin()) {
        if (!atMax()) {
          state <- MatchState$matchBranch()
        } else {
          state <- MatchState$matchComplete()
        }
      } else {
        state <- MatchState$matchContinue()
      }
    } elif (MatchState$equals(state,MatchState$matchFail())) {
      failed <- true
    }
  }

  @value incrementMatch () -> ()
  incrementMatch () {
    repetitionCount <- repetitionCount+1
  }

  @value atMax () -> (Bool)
  atMax () {
    return max > 0 && repetitionCount >= max
  }

  @value reachedMin () -> (Bool)
  reachedMin () {
    return repetitionCount >= min
  }

  @value startRepeat () -> ()
  startRepeat () {
    matcher <- matcher.copyWithReset()
  }
}

define SequenceMatcher {
  @value optional ReadSequence<Matcher<#c>> matchers
  @value optional ReadSequence<Matcher<#c>> current
  @value optional SequenceMatcher<#c> branch
  @value Bool failed

  create (matchers) {
    return SequenceMatcher<#c>{ matchers, matchers, empty, false }
  }

  copyWithReset () {
    optional ReadSequence<Matcher<#c>> matchers2 <- copySequence(matchers)
    return SequenceMatcher<#c>{ matchers2, matchers2, empty, false }
  }

  matchesEmpty () {
    scoped {
      optional ReadSequence<Matcher<#c>> current2 <- current
    } in while (present(current2)) {
      if (!require(current2).value().matchesEmpty()) {
        return false
      }
    } update {
      current2 <- require(current2).next()
    }
    return true
  }

  tryNextMatch (data) (state) {
    if (!present(current) || failed) {
      failed <- true
      return MatchState$matchFail()
    }
    branch <- empty
    state <- MatchState$matchFail()
    while (!atEnd()) {
      // Skip over any matcher that fails but could have matched empty.
      Bool emptyAllowed <- require(current).value().matchesEmpty()
      state <- require(current).value().tryNextMatch(data)
      if (!MatchState$equals(state,MatchState$matchFail()) || !emptyAllowed) {
        break
      }
    } update {
      ~ startNext()
    }
    // matchContinue() is passed on.
    if (MatchState$equals(state,MatchState$matchBranch())) {
      optional ReadSequence<Matcher<#c>> matchers2 <- copySequence(require(current).next())
      if (present(matchers2)) {
        branch <- SequenceMatcher<#c>{ matchers2, matchers2, empty, false }
        state <- MatchState$matchContinue()
      } else {
        state <- MatchState$matchBranch()
      }
    } elif (MatchState$equals(state,MatchState$matchComplete())) {
      ~ startNext()
      if (atEnd()) {
        state <- MatchState$matchComplete()
      } else {
        state <- MatchState$matchContinue()
      }
    } elif (MatchState$equals(state,MatchState$matchFail())) {
      failed <- true
    }
  }

  getBranch () {
    return branch
  }

  @type copySequence
  (optional ReadSequence<Matcher<#c>>) -> (optional LinkedNode<Matcher<#c>>)
  copySequence (head) (head2) {
    head2 <- empty
    scoped {
      optional LinkedNode<Matcher<#c>> tail <- empty
      optional ReadSequence<Matcher<#c>> current <- head
    } in while (present(current)) {
      LinkedNode<Matcher<#c>> node <-
          LinkedNode<Matcher<#c>>$create(require(current).value().copyWithReset(),empty)
      if (!present(head2)) {
        head2 <- node
        tail <- node
      } else {
        ~ require(tail).setNext(node)
        tail <- node
      }
    } update {
      current <- require(current).next()
    }
  }

  @value startNext () -> ()
  startNext () {
    if (present(current)) {
      current <- require(current).next()
    }
  }

  @value atEnd () -> (Bool)
  atEnd () {
    return !present(current)
  }
}

define LinkedNode {
  @value optional ReadSequence<#x> parent
  @value #x data

  create (data,parent) {
    return LinkedNode<#x>{ parent, data }
  }

  value () {
    return data
  }

  next () {
    return parent
  }

  setNext (parent2) {
    parent <- parent2
  }
}
