/* -----------------------------------------------------------------------------
Copyright 2020 Kevin P. Barry

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----------------------------------------------------------------------------- */

// Author: Kevin P. Barry [ta0kira@gmail.com]

// TODO: Split this up into smaller files based on what's being tested.
// TODO: Find a suitable replacement for checking line numbers in errors.

testcase "do nothing" {
  success Test$run()
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "fail builtin" {
  crash Test$run()
  require "Failed"
}

define Test {
  @category failedReturn () -> (Int)
  failedReturn () {
    fail("Failed")
  }

  run () {
    Int value <- failedReturn()
  }
}

concrete Test {
  @type run () -> ()
}



testcase "wrong type for fail" {
  error
  require "fail"
  require "Formatted"
}

concrete Value {
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  run () {
    fail(Value$create())
  }
}

concrete Test {
  @type run () -> ()
}


testcase "fail writer" {
  crash Test$run()
  require "Failed"
}

define Test {
  run () {
    ~ LazyStream<Formatted>$new().append("Failed").writeTo(SimpleOutput$error())
  }
}

concrete Test {
  @type run () -> ()
}


testcase "require empty" {
  crash Test$run()
  require "require.+empty"
}

define Test {
  run () {
    ~ require(empty)
  }
}

concrete Test {
  @type run () -> ()
}


testcase "@type member not allowed" {
  error
  require "not allowed"
}

define Test {
  @type Bool value <- false

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "@category member from @type" {
  success Test$run()
}

define Test {
  @category Bool value <- true

  @type call () -> ()
  call () {
    ~ value
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "@category member from @value" {
  success Test$run()
}

define Test {
  @category Bool value <- true

  @value call () -> ()
  call () {
    ~ value
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "@category to @category" {
  error
  require "get"
}

define Test {
  @category Bool value <- get()

  @category get () -> (Bool)
  get () {
    return true
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "@category member is lazy" {
  success Test$run()
}

concrete Util {
  @type doNotUse () -> (Bool)
}

define Util {
  doNotUse () {
    fail("do not use")
  }
}

define Test {
  @category Bool value <- Util$doNotUse()

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "@category member init when read" {
  crash Test$run()
  require "do not use"
}

concrete Util {
  @type doNotUse () -> (Bool)
}

define Util {
  doNotUse () {
    fail("do not use")
  }
}

define Test {
  @category Bool value <- Util$doNotUse()

  run () {
    Bool value2 <- value
  }
}

concrete Test {
  @type run () -> ()
}


testcase "@category member init when assigned" {
  crash Test$run()
  require "do not use"
}

concrete Util {
  @type doNotUse () -> (Bool)
}

define Util {
  doNotUse () {
    fail("do not use")
  }
}

define Test {
  @category Bool value <- Util$doNotUse()

  run () {
    value <- false
  }
}

concrete Test {
  @type run () -> ()
}


testcase "@category member init when ignored" {
  crash Test$run()
  require "do not use"
}

concrete Util {
  @type doNotUse () -> (Bool)
}

define Util {
  doNotUse () {
    fail("do not use")
  }
}

define Test {
  @category Bool value <- Util$doNotUse()

  run () {
    ~ value
  }
}

concrete Test {
  @type run () -> ()
}


testcase "@category member inline assignment" {
  success Test$run()
}

define Test {
  @category Bool value <- true

  @type call () -> (Bool)
  call () {
    return (value <- false)
  }

  run () {
    if (call() || value) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "@category init cycle" {
  crash Test$run()
  require "Value1|Value2"
}

concrete Value1 {
  @type get () -> (Bool)
}

concrete Value2 {
  @type get () -> (Bool)
}

define Value1 {
  @category Bool value <- Value2$get()

  get () {
    return value
  }
}

define Value2 {
  @category Bool value <- Value1$get()

  get () {
    return value
  }
}

define Test {
  run () {
    ~ Value1$get()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "self in @category init" {
  error
  require "self"
}

define Test {
  @category Test value <- self

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "self in @category function" {
  error
  require "self"
}

define Test {
  @category call () -> ()
  call () {
    Test value <- self
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "cycle in @category init" {
  error
  require "disallowed"
}

define Test {
  @category Bool value <- get()

  @category get () -> (Bool)
  get () {
    return value
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "value init in @category member" {
  success Test$run()
}

define Test {
  @value Int value
  @category Test singleton <- Test{ 3 }

  @value get () -> (Int)
  get () {
    return value
  }

  run () {
    if (singleton.get() != 3) {
      fail(singleton.get())
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "init value same type from @type" {
  success Test$run()
}

concrete Value<#x> {
  @type create (#x) -> (Value<#x>)
  @value get () -> (#x)
}

define Value {
  @value #x value

  create (val) {
    return Value<#x>{ val }
  }

  get () {
    return value
  }
}

define Test {
  run () {
    Value<Int> value <- Value<Int>$create(1)
    if (value.get() != 1) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "init value different type from @type" {
  success Test$run()
}

concrete Value<#x> {
  @type create<#y> (#y) -> (Value<#y>)
  @value get () -> (#x)
}

define Value {
  @value #x value

  create (val) {
    return Value<#y>{ val }
  }

  get () {
    return value
  }
}

define Test {
  run () {
    Value<Int> value <- Value<String>$create<Int>(1)
    if (value.get() != 1) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "init value same type from @value" {
  success Test$run()
}

concrete Value<#x> {
  @type create (#x) -> (Value<#x>)
  @value create2 (#x) -> (Value<#x>)
  @value get () -> (#x)
}

define Value {
  @value #x value

  create (val) {
    return Value<#x>{ val }
  }

  create2 (val) {
    return Value<#x>{ val }
  }

  get () {
    return value
  }
}

define Test {
  run () {
    Value<Int> value <- Value<Int>$create(2).create2(1)
    if (value.get() != 1) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "init value different type from @value" {
  success Test$run()
}

concrete Value<#x> {
  @type create (#x) -> (Value<#x>)
  @value create2<#y> (#y) -> (Value<#y>)
  @value get () -> (#x)
}

define Value {
  @value #x value

  create (val) {
    return Value<#x>{ val }
  }

  create2 (val) {
    return Value<#y>{ val }
  }

  get () {
    return value
  }
}

define Test {
  run () {
    Value<Int> value <- Value<String>$create("x").create2<Int>(1)
    if (value.get() != 1) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "missing assign" {
//  'value' 'line 5'
  error
}

@value interface Value {}

define Test {
  @value process () -> (Value)
  process () (value) {}

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign before logical" {
  success Test$run()
}

define Test {
  @value process () -> (Bool)
  process () (value) {
    ~ (value <- true) || false
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign after logical" {
  error
  require "value"
}

define Test {
  @value process () -> (Bool)
  process () (value) {
    ~ false || (value <- true)
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign before arithmetic" {
  success Test$run()
}

define Test {
  @value process () -> (Int)
  process () (value) {
    ~ (value <- 1) + 2
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign after arithmetic" {
  success Test$run()
}

define Test {
  @value process () -> (Int)
  process () (value) {
    ~ 2 + (value <- 1)
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "return used before assigned" {
  error
  require "value.+initialized"
}

define Test {
  @category process () -> (Int)
  process () (value) {
    value <- value+1
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "return used after assigned" {
  success Test$run()
}

define Test {
  @category process () -> (Int)
  process () (value) {
    value <- 1
    value <- value+1
  }

  run () {
    Int value <- process()
    if (value != 2) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "returns in correct order" {
  success Test$run()
}

define Test {
  @type get () -> (Int,Int)
  get () {
    return { 1, 2 }
  }

  run () {
    scoped {
      { Int x, Int y } <- get()
    } in if (x != 1) {
      fail("Failed")
    } elif (y != 2) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "assigns in correct order" {
  success Test$run()
}

concrete Value {
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  @type get () -> (Value,Int,Int)
  get () (v,x,y) {
    // This makes sure that x and y (primitive) are offset.
    v <- Value$create()
    x <- 1
    y <- 2
  }

  run () {
    scoped {
      { _, Int x, Int y } <- get()
    } in if (x != 1) {
      fail("Failed")
    } elif (y != 2) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "assigns in correct order with explicit return" {
  success Test$run()
}

define Test {
  @type get () -> (Int,Int)
  get () (x,y) {
    x <- 1
    y <- 2
    return _
  }

  run () {
    scoped {
      { Int x, Int y } <- get()
    } in if (x != 1) {
      fail("Failed")
    } elif (y != 2) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "overwrite arg" {
  error
  require "arg"
}

define Test {
  @type call (Int) -> ()
  call (arg) {
    arg <- 2
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "missing return" {
  error
  require "Value"
}

@value interface Value {}

define Test {
  @value process () -> (Value)
  process () {}

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "positional return with no names assigned" {
  success Test$run()
}

define Test {
  @type get () -> (Int,Int)
  get () (x,y) {
    if (false) {
      x <- 1
    } else {
      return { 3, 4 }
    }
    y <- 2
  }

  run () {
    scoped {
      { Int x, Int y } <- get()
    } in if (x != 3) {
      fail("Failed")
    } elif (y != 4) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "positional return instead of names" {
  success Test$run()
}

define Test {
  @type get () -> (Int,Int)
  get () (x,y) {
    return { 1, 2 }
  }

  run () {
    scoped {
      { Int x, Int y } <- get()
    } in if (x != 1) {
      fail("Failed")
    } elif (y != 2) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "positional return with some names assigned" {
  success Test$run()
}

define Test {
  @type get () -> (Int,Int)
  get () (x,y) {
    y <- 2
    if (false) {
      x <- 1
    } else {
      return { 3, 4 }
    }
  }

  run () {
    scoped {
      { Int x, Int y } <- get()
    } in if (x != 3) {
      fail("Failed")
    } elif (y != 4) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "return if/elif/else" {
  success Test$run()
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () {
    if (false) {
      return empty
    } elif (false) {
      return empty
    } else {
      return empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign if/elif/else" {
  success Test$run()
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    if (false) {
      value <- empty
    } elif (false) {
      value <- empty
    } else {
      value <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "missing in if" {
  error
  require "value"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    if (false) {
    } elif (false) {
      value <- empty
    } else {
      value <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "missing in elif" {
  error
  require "value"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    if (false) {
      value <- empty
    } elif (false) {
    } else {
      value <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "missing in else" {
  error
  require "value"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    if (false) {
      value <- empty
    } elif (false) {
      value <- empty
    } else {
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "missing in implicit else" {
  error
  require "value"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    if (false) {
      value <- empty
    } elif (false) {
      value <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign while" {
  error
  require "value"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    while (false) {
      value <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign while condition" {
  error
  require "value"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    while (present((value <- empty))) {}
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign if/elif condition" {
  error
  require "value"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    if (present((value <- empty))) {
    } elif (present((value <- empty))) {
    } else {
      value <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "return while" {
  error
  require "Value"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () {
    while (false) {
      return empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "return inside scope" {
  success Test$run()
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () {
    scoped {
      return empty
    } in ~ empty
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "return from scoped" {
  success Test$run()
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () {
    scoped {
    } in return empty
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "break outside of while" {
  error
  require "while"
}

define Test {
  run () {
    break
  }
}

concrete Test {
  @type run () -> ()
}


testcase "continue outside of while" {
  error
  require "while"
}

define Test {
  run () {
    continue
  }
}

concrete Test {
  @type run () -> ()
}


testcase "while with break" {
  success Test$run()
}

define Test {
  run () {
    Int output <- -1
    scoped {
      Int i <- 0
      Int limit <- 5
    } in while (i < limit) {
      output <- i
      break
      fail("Failed")
    }
    if (output != 0) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "while with update" {
  success Test$run()
}

define Test {
  run () {
    Int output <- -1
    scoped {
      Int i <- 0
      Int limit <- 5
    } in while (i < limit) {
      output <- i
    } update {
      i <- i+1
    }
    if (output != 4) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "break in update" {
  success Test$run()
}

define Test {
  run () {
    Int output <- 0
    while (true) {
    } update {
      if (output > 5) {
        break
        fail("Failed")
      }
      output <- output+1
    }
    if (output != 6) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "return in update" {
  success Test$run()
}

define Test {
  @type test () -> (Int)
  test () {
    Int output <- 0
    while ((output <- output+1) > 0) {
    } update {
      if (output > 5) {
        return output
        fail("Failed")
      }
    }
    return -1
  }

  run () {
    if (test() != 6) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "break and continue in if/else" {
  success Test$run()
}

define Test {
  run () {
    Int i <- 0
    while (true) {
      if (i > 5) {
        break
      } else {
        continue
      }
      fail("Failed")
    } update {
      i <- i+1
    }
    if (i != 6) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "update clashes with while" {
  success Test$run()
}

define Test {
  run () {
    while (false) {
      Int x <- 2
    } update {
      Int x <- 1
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "update clashes with scoped" {
  error
  require "x"
}

define Test {
  run () {
    scoped {
      Int x <- 2
    } in while (false) {
    } update {
      Int x <- 1
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "while without update" {
  success Test$run()
}

define Test {
  run () {
    Int output <- -1
    scoped {
      Int i <- 0
      Int limit <- 5
    } in while (i < limit) {
      output <- i
      i <- i+1
    }
    if (output != 4) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "while with continue and update" {
  success Test$run()
}

define Test {
  run () {
    Int output <- -1
    scoped {
      Int i <- 0
      Int limit <- 5
    } in while (i < limit) {
      output <- i
      continue
      fail("Failed")
    } update {
      i <- i+1
    }
    if (output != 4) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "while with continue and without update" {
  success Test$run()
}

define Test {
  run () {
    Int output <- -1
    scoped {
      Int i <- 0
      Int limit <- 5
    } in while (i < limit) {
      output <- i
      i <- i+1
      continue
      fail("Failed")
    }
    if (output != 4) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "crash in if" {
  crash Test$run()
  require "empty"
}

define Test {
  run () {
    optional Bool test <- empty
    if (require(test)) {
      // empty
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "crash in elif" {
  crash Test$run()
  require "empty"
}

define Test {
  run () {
    optional Bool test <- empty
    if (false) {
    } elif (require(test)) {
      // empty
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "crash in while" {
  crash Test$run()
  require "empty"
}

define Test {
  run () {
    optional Bool test <- empty
    while (require(test)) {
      // empty
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "assign inside scope" {
  success Test$run()
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    scoped {
      value <- empty
    } in ~ empty
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "assign from scoped" {
  success Test$run()
}

@value interface Value {}

define Test {
  @value process () -> (optional Value)
  process () (value) {
    scoped {
    } in value <- empty
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "optional persists" {
  success Test$run()
}

define Test {
  @value optional Test self2

  @type create () -> (Test)
  create () {
    return Test{ empty }
  }

  @value set () -> ()
  set () {
    scoped {
      Test value <- create()
    } in self2 <- value
  }

  @value check () -> ()
  check () {
    ~ require(self2)
  }

  run () {
    Test value <- create()
    ~ value.set()
    ~ value.check()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "weak is weak" {
  success Test$run()
}

define Test {
  @value weak Test self2

  @type create () -> (Test)
  create () {
    return Test{ empty }
  }

  @value set () -> ()
  set () {
    scoped {
      Test value <- create()
    } in self2 <- value
  }

  @value check () -> ()
  check () {
    scoped {
      optional Test self3 <- strong(self2)
    } in if (present(self3)) {
      fail("Failed")
    }
  }

  run () {
    Test value <- create()
    ~ value.set()
    ~ value.check()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "present weak" {
  success Test$run()
}

define Test {
  @type create () -> (Test)
  create () {
    return Test{}
  }

  @value check () -> ()
  check () {
    weak Test value <- create()
    if (present(strong(value))) {
// value should be nullptr here
      fail("Failed")
    }
  }

  run () {
    Test value <- create()
    ~ value.check()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "weak variable to weak variable" {
  success Test$run()
}

define Test {
  @category weak Test one <- empty

  run () {
    weak Test two <- one
    one <- two
  }
}

concrete Test {
  @type run () -> ()
}


testcase "optional variable to weak variable" {
  success Test$run()
}

define Test {
  @category optional Test one <- empty

  run () {
    weak Test two <- one
    two <- one
  }
}

concrete Test {
  @type run () -> ()
}


testcase "weak in multi assign" {
  success Test$run()
}

concrete Value {
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  @type get () -> (Value,Value)
  get () {
    Value value <- Value$create()
    return { value, value }
  }

  run () {
    // value1 ensures value2 is present.
    { Value value1, weak Value value2 } <- get()
    if (!present(strong(value2))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "weak in inline assign" {
  success Test$run()
}

concrete Value {
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value1 <- Value$create()
    weak Value value2 <- empty
    if (!present(strong((value2 <- value1)))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "not true" {
  success Test$run()
}

define Test {
  run () {
    if (!true) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "present required" {
  success Test$run()
}

define Test {
  @type create () -> (Test)
  create () {
    return Test{}
  }

  run () {
    Test value <- create()
    if (!present(value)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "require required" {
  success Test$run()
}

define Test {
  @type create () -> (Test)
  create () {
    return Test{}
  }

  @value call () -> ()
  call () {}

  run () {
    Test value <- create()
    ~ require(value).call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "multi assign if/elif/else" {
  success Test$run()
}

@value interface Value {}

define Test {
  @value process () -> (optional Value,optional Value)
  process () (value1,value2) {
    if (false) {
      value1 <- empty
      value2 <- empty
    } elif (false) {
      value1 <- empty
      value2 <- empty
    } else {
      value1 <- empty
      value2 <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "multi missing in if" {
  error
  require "value2"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value,optional Value)
  process () (value1,value2) {
    if (false) {
      value1 <- empty
    } elif (false) {
      value1 <- empty
      value2 <- empty
    } else {
      value1 <- empty
      value2 <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "multi missing in elif" {
  error
  require "value2"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value,optional Value)
  process () (value1,value2) {
    if (false) {
      value1 <- empty
      value2 <- empty
    } elif (false) {
      value1 <- empty
    } else {
      value1 <- empty
      value2 <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "multi missing in else" {
  error
  require "value2"
}

@value interface Value {}

define Test {
  @value process () -> (optional Value,optional Value)
  process () (value1,value2) {
    if (false) {
      value1 <- empty
      value2 <- empty
    } elif (false) {
      value1 <- empty
      value2 <- empty
    } else {
      value1 <- empty
    }
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "multi return to call" {
  error
  require "call.+\{Value,Value\}"
}

@value interface Value {
  get () -> (Value,Value)
  call () -> ()
}

define Test {
  @value process (Value) -> ()
  process (value) {
    ~ value.get().call()
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "zero return to call" {
  error
  require "call.+\{\}"
}

@value interface Value {
  get () -> ()
  call () -> ()
}

define Test {
  @value process (Value) -> ()
  process (value) {
    ~ value.get().call()
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "multi return assign" {
  success Test$run()
}

define Test {
  @type create () -> (Test)
  create () {
    return Test{}
  }

  @value double () -> (Test,Test)
  double () {
    return { self, self }
  }

  run () {
    Test value <- create()
    { _, Test value2 } <- value.double()
    { value, _ } <- value2.double()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "multi return as args" {
  success Test$run()
}

define Test {
  @type get () -> (Int,Int)
  get () {
    return { 1, 2 }
  }

  @type call (Int,Int) -> ()
  call (x,y) {
    if (x != 1) {
      fail("Failed")
    }
    if (y != 2) {
      fail("Failed")
    }
  }

  run () {
    ~ call(get())
  }
}

concrete Test {
  @type run () -> ()
}


testcase "converted call" {
  success Test$run()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value <- Value$create()
    ~ value.Base$call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "converted call bad type" {
  error
  require "Base"
}

@value interface Base {
  call () -> ()
}

concrete Value {
  @value call () -> ()
  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value <- Value$create()
    ~ value.Base$call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "call from union" {
  error
  require "\[Base\|Value\]"
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  run () {
    [Base|Value] value <- Value$create()
    ~ value.call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "call from union with conversion" {
  success Test$run()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  run () {
    [Base|Value] value <- Value$create()
    ~ value.Base$call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "call from intersect" {
  success Test$run()
}

@value interface Base1 {
  call () -> ()
}

@value interface Base2 {}

concrete Value {
  refines Base1
  refines Base2

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  run () {
    [Base1&Base2] value <- Value$create()
    ~ value.call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "call from intersect with conversion" {
  success Test$run()
}

@value interface Base1 {
  call () -> ()
}

@value interface Base2 {}

concrete Value {
  refines Base1
  refines Base2

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  run () {
    [Base1&Base2] value <- Value$create()
    ~ value.Base1$call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "call from intersect with conversion" {
  success Test$run()
}

@value interface Base1 {
  call () -> ()
}

@value interface Base2 {}

concrete Value {
  refines Base1
  refines Base2

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  run () {
    [Base1&Base2] value <- Value$create()
    ~ value.Base1$call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "call from param type" {
  success Test$run()
}

@type interface Base {
  call () -> ()
}

concrete Value {
  defines Base
}

define Value {
  call () {}
}

define Test {
  @type check<#x>
    #x defines Base
  () -> ()
  check () {
    ~ #x$call()
  }

  run () {
    ~ check<Value>()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "call from bad param type" {
  error
  require "call.+param #x"
}

@type interface Base {
  call () -> ()
}

define Test {
  @type check<#x>
  () -> ()
  check () {
    ~ #x$call()
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "call from param value" {
  success Test$run()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  @type check<#x>
    #x requires Base
  (#x) -> ()
  check (value) {
    ~ value.call()
  }

  run () {
    Value value <- Value$create()
    ~ check<Value>(value)
  }
}

concrete Test {
  @type run () -> ()
}


testcase "call from bad param value" {
//  'call.+param #x' 'line 9'
  error
}

@value interface Base {
  call () -> ()
}

define Test {
  @type check<#x>
  (#x) -> ()
  check (value) {
    ~ value.call()
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "convert arg" {
  success Test$run()
}

@value interface Base {
  call () -> ()
}

concrete Value {
  refines Base

  @type create () -> (Value)
}

define Value {
  call () {}

  create () {
    return Value{}
  }
}

define Test {
  @type convert (Value) -> (Base)
  convert (value) {
    return value
  }

  run () {
   ~ convert(Value$create()).call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "bad convert arg" {
  error
  require "does not refine Value"
}

@value interface Base {}

concrete Value {}

define Value {}

define Test {
  @type convert (Base) -> (Value)
  convert (value) {
    return value
  }

  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "external filter not applied in @category" {
  success Test$run()
}

concrete Value<#x> {
  #x defines LessThan<#x>

  @category something<#x> () -> ()
}

define Value {
  something () {}
}

define Test {
  run () {
    ~ Value$$something<Bool>()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "internal param not visible from @type" {
//  '#x' 'line 8'
  error
}

concrete Value {}

define Value {
  types<#x> {}

  @type something () -> ()
  something () {
    optional #x val <- empty
  }
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "internal filter not applied in @type" {
  success Test$run()
}

concrete Value {
  @type something<#x> () -> ()
}

define Value {
  types<#x> {
    #x defines LessThan<#x>
  }

  something () {}
}

define Test {
  run () {
    ~ Value$something<Bool>()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "internal filter not applied in @category" {
  success Test$run()
}

concrete Value {
  @category something<#x> () -> ()
}

define Value {
  types<#x> {
    #x defines LessThan<#x>
  }

  something () {}
}

define Test {
  run () {
    ~ Value$$something<Bool>()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "internal params" {
  success Test$run()
}

concrete Value {
  @type create<#x,#y>
  () -> (Value)
}

define Value {
  types<#x,#y> {}

  create () {
    return Value{ types<#x,#y> }
  }
}

@value interface Type1 {}
@value interface Type2 {}

define Test {
  run () {
    ~ Value$create<Type1,Type2>()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "internal params with filters" {
  success Test$run()
}

@value interface Get<|#x> {
  get () -> (#x)
}

@value interface Set<#x|> {
  set (#x) -> ()
}

concrete Value {
  @type create<#x,#y>
    #x requires Get<#x>
    #y allows Set<#y>
  () -> (Value)
}

define Value {
  types<#x,#y> {
    #x requires Get<#x>
    #y allows Set<#y>
  }

  create () {
    return Value{ types<#x,#y> }
  }
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "internal params missing filters" {
  error
  require "Get|Set"
}

@value interface Get<|#x> {
  get () -> (#x)
}

@value interface Set<#x|> {
  set (#x) -> ()
}

concrete Value {
  @category create<#x,#y>
  () -> (Value)
}

define Value {
  types<#x,#y> {
    #x requires Get<#x>
    #y allows Set<#y>
  }

  create () {
    return Value{ types<#x,#y> }
  }
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "internal params with values" {
  success Test$run()
}

concrete Value {
  @category create<#x,#y>
  () -> (Value)
}

define Value {
  types<#x,#y> {}

  @value Bool value

  create () {
    return Value{ types<#x,#y>, false }
  }
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "value depends on internal param" {
  success Test$run()
}

concrete Type<#y> {
  @type create () -> (Type<#y>)
}

define Type {
  create () {
    return Type<#y>{}
  }
}

concrete Value {
  @type create<#x>
  (Type<#x>) -> (Value)
}

define Value {
  types<#z> {}

  @value Type<#z> value

  create (value) {
    return Value{ types<#x>, value }
  }
}

define Test {
  run () {
    ~ Value$create<Bool>(Type<Bool>$create())
  }
}

concrete Test {
  @type run () -> ()
}


testcase "value mismatch with internal param" {
  error
  require "call"
  require "Bool"
  require "String"
}

concrete Type<#y> {
  @type create () -> (Type<#y>)
}

define Type {
  create () {
    return Type<#y>{}
  }
}

concrete Value {
  @type create<#x>
  (Type<#x>) -> (Value)
}

define Value {
  types<#z> {}

  @value Type<#z> value

  create (value) {
    return Value{ types<#x>, value }
  }
}

define Test {
  run () {
    ~ Value$create<String>(Type<Bool>$create())
  }
}

concrete Test {
  @type run () -> ()
}


testcase "internal param clash with external" {
  error
  require "#x"
}

concrete Value<#x> {}

define Value {
  types<#x> {}
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "internal param clash with function" {
  error
  require "#x"
}

concrete Value {
  @value check<#x> () -> ()
}

define Value {
  types<#x> {}
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "internal param clash with internal function" {
  error
  require "#x"
}

concrete Value {}

define Value {
  types<#x> {}

  @value check<#x> () -> ()
  check () {}
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "internal param no clash with category" {
  success Test$run()
}

concrete Value {
  @category create<#x> () -> (Value)
}

define Value {
  types<#x> {}

  create () {
    return Value { types<#x> }
  }
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "reduce to self" {
  success Test$run()
}

concrete Value {
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value <- Value$create()
    scoped {
      optional Value value2 <- reduce<Value,Value>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce to unrelated" {
  success Test$run()
}

concrete Value {
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value <- Value$create()
    scoped {
      optional Test value2 <- reduce<Value,Test>(value)
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce wrong arg type" {
  error
  require "argument"
}

concrete Value {
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value <- Value$create()
    optional Value value2 <- reduce<Test,Value>(value)
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce wrong return type" {
  error
  require "assignment"
}

concrete Value {
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value <- Value$create()
    optional Value value2 <- reduce<Value,Test>(value)
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce success with param" {
  success Test$run()
}

concrete Value<|#x> {
  @type create () -> (Value<#x>)

  @value attempt<#y>
  () -> (optional Value<#y>)
}

define Value {
  create () {
    return Value<#x>{}
  }

  attempt () {
    return reduce<Value<#x>,Value<#y>>(self)
  }
}

@value interface Type1 {}

@value interface Type2 {
  refines Type1
}

define Test {
  run () {
    Value<Type2> value <- Value<Type2>$create()
    scoped {
      optional Value<Type1> value2 <- value.attempt<Type1>()
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce fail with param" {
  success Test$run()
}

concrete Value<|#x> {
  @type create () -> (Value<#x>)

  @value attempt<#y>
  () -> (optional Value<#y>)
}

define Value {
  create () {
    return Value<#x>{}
  }

  attempt () {
    return reduce<Value<#x>,Value<#y>>(self)
  }
}

@value interface Type1 {}

@value interface Type2 {
  refines Type1
}

define Test {
  run () {
    Value<Type1> value <- Value<Type1>$create()
    scoped {
      optional Value<Type2> value2 <- value.attempt<Type2>()
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce success with contra param" {
  success Test$run()
}

concrete Value<#x|> {
  @type create () -> (Value<#x>)

  @value attempt<#y>
  () -> (optional Value<#y>)
}

define Value {
  create () {
    return Value<#x>{}
  }

  attempt () {
    return reduce<Value<#x>,Value<#y>>(self)
  }
}

@value interface Type1 {}

@value interface Type2 {
  refines Type1
}

define Test {
  run () {
    Value<Value<Type2>> value <- Value<Value<Type2>>$create()
    scoped {
      optional Value<Value<Type1>> value2 <- value.attempt<Value<Type1>>()
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce fail with contra param" {
  success Test$run()
}

concrete Value<#x|> {
  @type create () -> (Value<#x>)

  @value attempt<#y>
  () -> (optional Value<#y>)
}

define Value {
  create () {
    return Value<#x>{}
  }

  attempt () {
    return reduce<Value<#x>,Value<#y>>(self)
  }
}

@value interface Type1 {}

@value interface Type2 {
  refines Type1
}

define Test {
  run () {
    Value<Value<Type1>> value <- Value<Value<Type1>>$create()
    scoped {
      optional Value<Value<Type2>> value2 <- value.attempt<Value<Type2>>()
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce success from union" {
  success Test$run()
}

@value interface Base {}

concrete Value1 {
  refines Base

  @type create () -> (Value1)
}

define Value1 {
  create () {
    return Value1{}
  }
}

@value interface Value2 {
  refines Base
}

define Test {
  run () {
    [Value1|Value2] value <- Value1$create()
    scoped {
      optional Base value2 <- reduce<[Value1|Value2],Base>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce fail from union" {
  success Test$run()
}

@value interface Base {}

concrete Value1 {
  refines Base

  @type create () -> (Value1)
}

define Value1 {
  create () {
    return Value1{}
  }
}

@value interface Value2 {
  refines Base
}

define Test {
  run () {
    [Value1|Value2] value <- Value1$create()
    scoped {
      optional Value2 value2 <- reduce<[Value1|Value2],Value2>(value)
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce success to intersect" {
  success Test$run()
}

@value interface Base1 {}

@value interface Base2 {}

concrete Value {
  refines Base1
  refines Base2

  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value <- Value$create()
    scoped {
      optional [Base1&Base2] value2 <- reduce<Value,[Base1&Base2]>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce fail to intersect" {
  success Test$run()
}

@value interface Base1 {}

@value interface Base2 {}

concrete Value {
  refines Base1

  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }
}

define Test {
  run () {
    Value value <- Value$create()
    scoped {
      optional [Base1&Base2] value2 <- reduce<Value,[Base1&Base2]>(value)
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce success union to intersect" {
  success Test$run()
}

@value interface Base1 {}

@value interface Base2 {}

@value interface Value1 {
  refines Base1
  refines Base2
}

concrete Value2 {
  refines Base1
  refines Base2

  @type create () -> (Value2)
}

define Value2 {
  create () {
    return Value2{}
  }
}

define Test {
  run () {
    [Value1|Value2] value <- Value2$create()
    scoped {
      optional [Base1&Base2] value2 <- reduce<[Value1|Value2],[Base1&Base2]>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce fail union to intersect" {
  success Test$run()
}

@value interface Base1 {}

@value interface Base2 {}

@value interface Value1 {
  refines Base1
  refines Base2
}

concrete Value2 {
  refines Base1

  @type create () -> (Value2)
}

define Value2 {
  create () {
    return Value2{}
  }
}

define Test {
  run () {
    [Value1|Value2] value <- Value2$create()
    scoped {
      optional [Base1&Base2] value2 <- reduce<[Value1|Value2],[Base1&Base2]>(value)
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce success intersect to union" {
  success Test$run()
}

@value interface Base1 {}

@value interface Base2 {}

@value interface Value1 {
  refines Base1
}

@value interface Value2 {}

concrete Data {
  refines Value1
  refines Value2

  @type create () -> (Data)
}

define Data {
  create () {
    return Data{}
  }
}

define Test {
  run () {
    [Value1&Value2] value <- Data$create()
    scoped {
      optional [Base1|Base2] value2 <- reduce<[Value1&Value2],[Base1|Base2]>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce fail intersect to union" {
  success Test$run()
}

@value interface Base1 {}

@value interface Base2 {}

@value interface Value1 {}

@value interface Value2 {}

concrete Data {
  refines Value1
  refines Value2

  @type create () -> (Data)
}

define Data {
  create () {
    return Data{}
  }
}

define Test {
  run () {
    [Value1&Value2] value <- Data$create()
    scoped {
      optional [Base1|Base2] value2 <- reduce<[Value1&Value2],[Base1|Base2]>(value)
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce succeeds to covariant any" {
  success Test$run()
}

concrete Value<|#x> {
  @type create () -> (Value<#x>)
}

define Value {
  create () {
    return Value<#x>{}
  }
}

define Test {
  run () {
    Value<Test> value <- Value<Test>$create()
    scoped {
      optional Value<any> value2 <- reduce<Value<Test>,Value<any>>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce succeeds to contravariant all" {
  success Test$run()
}

concrete Value<#x|> {
  @type create () -> (Value<#x>)
}

define Value {
  create () {
    return Value<#x>{}
  }
}

define Test {
  run () {
    Value<Test> value <- Value<Test>$create()
    scoped {
      optional Value<all> value2 <- reduce<Value<Test>,Value<all>>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce fails to invariant any" {
  success Test$run()
}

concrete Value<#x> {
  @type create () -> (Value<#x>)
}

define Value {
  create () {
    return Value<#x>{}
  }
}

define Test {
  run () {
    Value<Test> value <- Value<Test>$create()
    scoped {
      optional Value<any> value2 <- reduce<Value<Test>,Value<any>>(value)
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce succeeds from covariant all" {
  success Test$run()
}

concrete Value<|#x> {
  @type create () -> (Value<#x>)
}

define Value {
  create () {
    return Value<#x>{}
  }
}

define Test {
  run () {
    Value<all> value <- Value<all>$create()
    scoped {
      optional Value<Test> value2 <- reduce<Value<all>,Value<Test>>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce succeeds from contravariant any" {
  success Test$run()
}

concrete Value<#x|> {
  @type create () -> (Value<#x>)
}

define Value {
  create () {
    return Value<#x>{}
  }
}

define Test {
  run () {
    Value<any> value <- Value<any>$create()
    scoped {
      optional Value<Test> value2 <- reduce<Value<any>,Value<Test>>(value)
    } in if (!present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce fails from invariant all" {
  success Test$run()
}

concrete Value<#x> {
  @type create () -> (Value<#x>)
}

define Value {
  create () {
    return Value<#x>{}
  }
}

define Test {
  run () {
    Value<all> value <- Value<all>$create()
    scoped {
      optional Value<Test> value2 <- reduce<Value<all>,Value<Test>>(value)
    } in if (present(value2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce Bool to Bool" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<Bool,Bool>(true))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce Bool to Formatted" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<Bool,Formatted>(true))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce Int to Int" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<Int,Int>(1))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce Int to Formatted" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<Int,Formatted>(1))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce String to String" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<String,String>("x"))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce String to Formatted" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<String,Formatted>("x"))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce Float to Float" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<Float,Float>(1.1))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce Float to Formatted" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<Float,Formatted>(1.1))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce ReadPosition success" {
  success Test$run()
}

define Test {
  run () {
    if (!present(reduce<ReadPosition<Char>,ReadPosition<Formatted>>("x"))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce ReadPosition fail" {
  success Test$run()
}

define Test {
  run () {
    if (present(reduce<ReadPosition<Formatted>,ReadPosition<Char>>("x"))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce internal param success" {
  success Test$run()
}

concrete Value {
  @type create<#x> () -> (Value)
  @value check<#y> (#y) -> (Bool)
}

define Value {
  types<#x> {}

  create () {
    return Value { types<#x> }
  }

  check (y) {
    return present(reduce<#y,#x>(y))
  }
}

define Test {
  run () {
    Value value <- Value$create<Formatted>()
    if (!value.check<String>("")) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "reduce internal param fail" {
  success Test$run()
}

concrete Value {
  @type create<#x> () -> (Value)
  @value check<#y> (#y) -> (Bool)
}

define Value {
  types<#x> {}

  create () {
    return Value { types<#x> }
  }

  check (y) {
    return present(reduce<#y,#x>(y))
  }
}

define Test {
  run () {
    Value value <- Value$create<Formatted>()
    if (value.check<Value>(value)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int arithmetic with precedence" {
  success Test$run()
}

define Test {
  run () {
    scoped {
      Int x <- 0x10 + 1 * 2 - 8 / 2 - 3 % 2
    } in if (x != 13) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int + bool" {
  error
  require "Int.+Bool"
}

define Test {
  run () {
    ~ 0x10 + false
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int + string" {
  error
  require "Int.+String"
}

define Test {
  run () {
    ~ 0x10 + ""
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string arithmetic" {
  success Test$run()
}

define Test {
  run () {
    scoped {
      String x <- "x" + "y" + "z"
    } in if (x != "xyz") {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "float arithmetic with precedence" {
  success Test$run()
}

define Test {
  run () {
    scoped {
      Float x <- 16.0 + 1.0 * 2.0 - 8.0 / 2.0 - 3.0 / 3.0
    } in if (x != 13.0) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "bool comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!(true  == true))  { fail("Failed") }
    if (!(false == false)) { fail("Failed") }
    if (!(false != true))  { fail("Failed") }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!(1 <  2)) { fail("Failed") }
    if (!(1 <= 2)) { fail("Failed") }
    if (!(1 == 1)) { fail("Failed") }
    if (!(1 != 2)) { fail("Failed") }
    if (!(2 >  1)) { fail("Failed") }
    if (!(2 >= 1)) { fail("Failed") }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "float comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!(1.0 <  2.0)) { fail("Failed") }
    if (!(1.0 <= 2.0)) { fail("Failed") }
    if (!(1.0 == 1.0)) { fail("Failed") }
    if (!(1.0 != 2.0)) { fail("Failed") }
    if (!(2.0 >  1.0)) { fail("Failed") }
    if (!(2.0 >= 1.0)) { fail("Failed") }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!("x" <  "y")) { fail("Failed") }
    if (!("x" <= "y")) { fail("Failed") }
    if (!("x" == "x")) { fail("Failed") }
    if (!("x" != "y")) { fail("Failed") }
    if (!("y" >  "x")) { fail("Failed") }
    if (!("y" >= "x")) { fail("Failed") }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "char comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!('x' <  'y')) { fail("Failed") }
    if (!('x' <= 'y')) { fail("Failed") }
    if (!('x' == 'x')) { fail("Failed") }
    if (!('x' != 'y')) { fail("Failed") }
    if (!('y' >  'x')) { fail("Failed") }
    if (!('y' >= 'x')) { fail("Failed") }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "bool logic with precedence" {
  success Test$run()
}

define Test {
  run () {
    scoped {
      Bool x <- false && false || true
    } in if (!x) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "minus string" {
  error
  require "String.+String"
}

define Test {
  run () {
    ~ "x" - "x"
  }
}

concrete Test {
  @type run () -> ()
}


testcase "arithmetic bool" {
  error
  require "Bool.+Bool"
}

define Test {
  run () {
    ~ true - false
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string plus with comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!("x" + "w" < "x" + "y")) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "char minus with comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!('d' - 'a' == 3)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int arithmetic with comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!(2 + 1 < 2 + 3)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "float arithmetic with comparison" {
  success Test$run()
}

define Test {
  run () {
    if (!(2.0 + 1.0 < 2.0 + 3.0)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "bool comparison" {
  error
  require "Bool.+Int"
}

define Test {
  run () {
    ~ 1 < 2 < 3
  }
}

concrete Test {
  @type run () -> ()
}


testcase "arithmetic, comparison, logic" {
  success Test$run()
}

define Test {
  run () {
    scoped {
      Bool x <- 1 + 2 < 4 && 3 >= 1 * 2 + 1
    } in if (!x) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string LessThan" {
  success Test$run()
}

define Test {
  run () {
    if (!String$lessThan("x","y")) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "bool Equals" {
  success Test$run()
}

define Test {
  run () {
    if (!Bool$equals(true,true)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string Equals" {
  success Test$run()
}

define Test {
  run () {
    if (!String$equals("x","x")) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "char LessThan" {
  success Test$run()
}

define Test {
  run () {
    if (!Char$lessThan('x','y')) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "char Equals" {
  success Test$run()
}

define Test {
  run () {
    if (!Char$equals('x','x')) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int LessThan" {
  success Test$run()
}

define Test {
  run () {
    if (!Int$lessThan(1,2)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int Equals" {
  success Test$run()
}

define Test {
  run () {
    if (!Int$equals(1,1)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "float LessThan" {
  success Test$run()
}

define Test {
  run () {
    if (!Float$lessThan(1.0,2.0)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "float Equals" {
  success Test$run()
}

define Test {
  run () {
    if (!Float$equals(1.0,1.0)) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "bool is shared" {
  success Test$run()
}

define Test {
  run () {
    Bool value1 <- true
    // Shared because true and false are boxed constants.
    weak Bool value2 <- value1
    if (!present(strong(value2))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string is shared" {
  success Test$run()
}

define Test {
  run () {
    String value1 <- "x"
    weak String value2 <- value1
    if (!present(strong(value2))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "char is not shared" {
  success Test$run()
}

define Test {
  run () {
    Char value1 <- 'x'
    weak Char value2 <- value1
    if (present(strong(value2))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int is not shared" {
  success Test$run()
}

define Test {
  run () {
    Int value1 <- 1
    weak Int value2 <- value1
    if (present(strong(value2))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "float is not shared" {
  success Test$run()
}

define Test {
  run () {
    Float value1 <- 1.1
    weak Float value2 <- value1
    if (present(strong(value2))) {
      fail("Failed")
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "internal merge" {
  success Test$run()
}

@value interface Interface {
  call () -> (Interface)
}

concrete Value {
  refines Interface
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }

  @value call () -> (Value)
  call () {
    return self
  }
}

define Test {
  run () {
    ~ Value$create().call().call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "internal merge failed" {
  error
  require "Interface2"
}

@value interface Interface {}

@value interface Interface2 {
  refines Interface
  call () -> (Interface2)
}

concrete Value {
  refines Interface2
  @type create () -> (Value)
}

define Value {
  create () {
    return Value{}
  }

  @value call () -> (Interface)
  call () {
    return self
  }
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "external merge" {
  success Test$run()
}

@value interface Interface {
  call () -> (Interface)
}

concrete Value {
  refines Interface
  @type create () -> (Value)
  @value call () -> (Value)
}

define Value {
  create () {
    return Value{}
  }

  call () {
    return self
  }
}

define Test {
  run () {
    ~ Value$create().call().call()
  }
}

concrete Test {
  @type run () -> ()
}


testcase "external merge failed" {
  error
  require "Interface2"
}

@value interface Interface {}

@value interface Interface2 {
  refines Interface
  call () -> (Interface2)
}

concrete Value {
  refines Interface2
  @type create () -> (Value)
  @value call () -> (Interface)
}

define Test {
  run () {}
}

concrete Test {
  @type run () -> ()
}


testcase "string access" {
  success Test$run()
}

define Test {
  run () {
    String s <- "abcde"
    Char c <- s.readPosition(3)
    if (c != 'd') {
      fail(c)
    }
    Int size <- s.readSize()
    if (size != 5) {
      fail(size)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string access negative" {
  crash Test$run()
  require "-10"
  require "bounds"
}

define Test {
  run () {
    ~ ("abc").readPosition(-10)
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string access past end" {
  crash Test$run()
  require "100"
  require "bounds"
}

define Test {
  run () {
    ~ ("abc").readPosition(100)
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string Formatted" {
  success Test$run()
}

define Test {
  run () {
    String s <- ("x").formatted()
    if (s != "x") {
      fail(s)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "char Formatted" {
  success Test$run()
}

define Test {
  run () {
    String s <- ('x').formatted()
    if (s != "x") {
      fail(s)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "char octal Formatted" {
  success Test$run()
}

define Test {
  run () {
    String s <- ('\170').formatted()
    if (s != "x") {
      fail(s)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "char hex Formatted" {
  success Test$run()
}

define Test {
  run () {
    String s <- ('\x78').formatted()
    if (s != "x") {
      fail(s)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int Formatted" {
  success Test$run()
}

define Test {
  run () {
    String s <- (1).formatted()
    if (s != "1") {
      fail(s)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int hex Formatted" {
  success Test$run()
}

define Test {
  run () {
    String s <- (0x0010).formatted()
    if (s != "16") {
      fail(s)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "float Formatted" {
  success Test$run()
}

define Test {
  run () {
    String s <- (1.1).formatted()
    if (s != "1.1") {  // precision might vary
      fail(s)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "bool Formatted" {
  success Test$run()
}

define Test {
  run () {
    String s <- (false).formatted()
    if (s != "false") {
      fail(s)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "string typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<String>()
    if (name.formatted() != "String") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "int typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<Int>()
    if (name.formatted() != "Int") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "float typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<Float>()
    if (name.formatted() != "Float") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "bool typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<Bool>()
    if (name.formatted() != "Bool") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "Formatted typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<Formatted>()
    if (name.formatted() != "Formatted") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "LessThan typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<LessThan<Int>>()
    if (name.formatted() != "LessThan<Int>") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "Equals typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<Equals<Int>>()
    if (name.formatted() != "Equals<Int>") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "any typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<any>()
    if (name.formatted() != "any") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "all typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<all>()
    if (name.formatted() != "all") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "intersect typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<[String&Int]>()
    if (name.formatted() != "[String&Int]") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "union typename" {
  success Test$run()
}

define Test {
  run () {
    Formatted name <- typename<[String|Int]>()
    if (name.formatted() != "[String|Int]") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "param typename" {
  success Test$run()
}

@value interface Type<#x,#y> {}

define Test {
  @category getTypename<#x,#y> () -> (Formatted)
  getTypename () {
    return typename<Type<#x,#y>>()
  }

  run () {
    Formatted name <- getTypename<String,LessThan<Int>>()
    if (name.formatted() != "Type<String,LessThan<Int>>") {
      fail(name)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "iterate string forward" {
  success Test$run()
}

define Test {
  run () {
    String s <- "abcde"
    Int count <- 0
    scoped {
      ReadIterator<Char> iter <- ReadIterator$$fromReadPosition<Char>(s)
    } in while (!iter.pastForwardEnd()) {
      if (iter.readCurrent() != s.readPosition(count)) {
        fail(iter.readCurrent())
      }
    } update {
      count <- count+1
      iter <- iter.forward()
    }
    if (count != s.readSize()) {
     fail(count)
    }
  }
}

concrete Test {
  @type run () -> ()
}


testcase "iterate string reverse" {
  success Test$run()
}

define Test {
  run () {
    String s <- "abcde"
    Int count <- s.readSize()-1
    scoped {
      ReadIterator<Char> iter <- ReadIterator$$fromReadPositionAt<Char>(s,count)
    } in while (!iter.pastReverseEnd()) {
      if (iter.readCurrent() != s.readPosition(count)) {
        fail(iter.readCurrent())
      }
    } update {
      count <- count-1
      iter <- iter.reverse()
    }
    if (count != -1) {
     fail(count)
    }
  }
}

concrete Test {
  @type run () -> ()
}
