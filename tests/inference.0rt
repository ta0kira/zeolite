/* -----------------------------------------------------------------------------
Copyright 2020 Kevin P. Barry

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----------------------------------------------------------------------------- */

// Author: Kevin P. Barry [ta0kira@gmail.com]

testcase "simple inference" {
  success
}

unittest test {
  \ Test.run()
}

define Test {
  run () {
    Int value <- get<?>(10)
  }

  @type get<#x> (#x) -> (#x)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "inference mismatch" {
  error
  require "get"
  require "String"
  require "Int"
}

define Test {
  run () {
    String value <- get<?>(10)
  }

  @type get<#x> (#x) -> (#x)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "nested inference" {
  success
}

unittest test {
  \ Test.run()
}

concrete Type<#x> {
  @type create () -> (Type<#x>)
}

define Type {
  create () {
    return Type<#x>{ }
  }
}

define Test {
  run () {
    Type<Int> value <- get<?>(Type<Int>.create())
  }

  @type get<#x> (Type<#x>) -> (Type<#x>)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "simple inference with qualification" {
  success
}

unittest test {
  \ Test.run()
}

define Test {
  run () {
    Int value <- Test.get<?>(10)
  }

  @type get<#x> (#x) -> (#x)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "inference mismatch with qualification" {
  error
  require "get"
  require "String"
  require "Int"
}

define Test {
  run () {
    String value <- Test.get<?>(10)
  }

  @type get<#x> (#x) -> (#x)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "nested inference with qualification" {
  success
}

unittest test {
  \ Test.run()
}

concrete Type<#x> {
  @type create () -> (Type<#x>)
}

define Type {
  create () {
    return Type<#x>{ }
  }
}

define Test {
  run () {
    Type<Int> value <- Test.get<?>(Type<Int>.create())
  }

  @type get<#x> (Type<#x>) -> (Type<#x>)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "inference conflict" {
  error
  require "get"
  require "#x"
}

concrete Type<#x> {
  @type create () -> (Type<#x>)
}

define Type {
  create () {
    return Type<#x>{ }
  }
}

define Test {
  run () {
    Type<Int> value <- get<?>(Type<Int>.create(),"bad")
  }

  @type get<#x> (Type<#x>,#x) -> (Type<#x>)
  get (x,_) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "elimination by filter" {
  error
  require "get"
  require "#x"
  require "Formatted.+String"
}

define Test {
  run () {
    \ get<?>("value")
  }

  @type get<#x>
    #x allows Formatted
  (#x) -> (#x)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "elimination by filter without param" {
  error
  require "get"
  require "#x"
  require "Formatted.+String"
}

define Test {
  run () {
    \ get<Formatted,?>("value")
  }

  @type get<#y,#x>
    #x allows #y
  (#x) -> (#x)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "elimination by filter including param" {
  error
  require "get"
  require "#x"
  require "String.+Type"
  require "Type.+String"
}

concrete Type<#x> {
  @type create () -> (Type<#x>)
}

define Type {
  create () {
    return Type<#x>{ }
  }
}

define Test {
  run () {
    \ get<?>(Type<String>.create())
  }

  @type get<#x>
    #x allows Type<#x>
  (#x) -> (#x)
  get (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "clashing param filter in the same scope" {
  success
}

unittest test {
  \ Test.run()
}

define Test {
  run () {
    \ get1<Int>()
  }

  @type get1<#x>
    #x requires Int
  () -> ()
  get1 () {
    String value <- get2<?>("message")
  }

  @type get2<#x> (#x) -> (#x)
  get2 (x) {
    return x
  }
}

concrete Test {
  @type run () -> ()
}


testcase "mutually dependent inferences" {
  error
  require "get"
  require "#x.+Int"
  require "#y.+String"
}

concrete Type<#x> {
  @type create () -> (Type<#x>)
}

define Type {
  create () {
    return Type<#x>{ }
  }
}

define Test {
  run () {
    Type<String> x <- Type<String>.create()
    Type<Int>    y <- Type<Int>.create()
    \ get<?,?>(x,y)
  }

  @type get<#x,#y>
    #x requires Type<#y>
    #y requires Type<#x>
  (#x,#y) -> ()
  get (_,_) {}
}

concrete Test {
  @type run () -> ()
}
